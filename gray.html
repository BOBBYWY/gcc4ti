<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>gray.h</TITLE>
<STYLE TYPE="TEXT/CSS">
<!--
.IE3-DUMMY { CONT-SIZE: 100%; }
BODY { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; }
P { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H1 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H2 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H3 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H4 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H5 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H6 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
UL { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #FFFFFF; }
.NOBORDER { BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.NOBORDER TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.CODE { FONT-FAMILY: Courier New; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#E0E0E0">
<FONT SIZE="5"><B>The &lt;gray.h&gt; Header File</B></FONT>
<HR>
<P><B>Routines for grayscale graphics</B></P>

<H3><U>Functions</U></H3>
<DL INDENT="20"><DT><B><A HREF="#GrayAdjust">GrayAdjust</A></B><DD>Adjusts grayscale support to make it flickerless.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayCheckRunning">GrayCheckRunning</A></B><DD>Checks whether grayscale mode is active.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufCleanup">GrayDBufCleanup</A></B><DD>Uninitializes grayscale double-buffering.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A></B><DD>Returns the index of the currently visible double buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufGetActivePlane">GrayDBufGetActivePlane</A></B><DD>Returns a pointer to a specific plane of the currently visible buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A></B><DD>Returns the index of the currently invisible double buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufGetHiddenPlane">GrayDBufGetHiddenPlane</A></B><DD>Returns a pointer to a specific plane of the currently hidden buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A></B><DD>Returns a pointer to a specific plane of a specific buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufInit">GrayDBufInit</A></B><DD>Initializes grayscale double-buffering mode.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufSetActiveAMSPlane">GrayDBufSetActiveAMSPlane</A></B><DD>Forces graphics routines to use selected plane of visible buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A></B><DD>Sets the currently visible double buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufSetActiveIdxSync">GrayDBufSetActiveIdxSync</A></B><DD>Synchronizes and sets the currently visible double buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufSetAMSPlane">GrayDBufSetAMSPlane</A></B><DD>Forces graphics routines to use selected plane of a specific buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufSetHiddenAMSPlane">GrayDBufSetHiddenAMSPlane</A></B><DD>Forces graphics routines to use selected plane of hidden buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufToggle">GrayDBufToggle</A></B><DD>Toggles the currently visible double buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayDBufToggleSync">GrayDBufToggleSync</A></B><DD>Synchronizes and toggles the currently visible double buffer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayGetInt1Handler">GrayGetInt1Handler</A></B><DD>Returns the interrupt handler executed by the grayscale algorithm.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayGetPlane">GrayGetPlane</A></B><DD>Gets the address of a grayscale plane.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayGetSwitchCount">GrayGetSwitchCount</A></B><DD>Returns the current plane switch counter.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayGetVersionString">GrayGetVersionString</A></B><DD>Returns the embedded grayscale support version string.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayMode">GrayMode</A></B><DD>This function has become obsolete.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayOff">GrayOff</A></B><DD>Deactivates grayscale mode.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayOn">GrayOn</A></B><DD>Activates grayscale mode with four shades of gray.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayOnThrow">GrayOnThrow</A></B><DD>Activates grayscale mode, throwing an error if unsuccessful.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GraySetAMSPlane">GraySetAMSPlane</A></B><DD>Forces graphics routines to use selected plane.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GraySetInt1Handler">GraySetInt1Handler</A></B><DD>Sets the interrupt handler executed by the grayscale algorithm.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GraySetSwitchCount">GraySetSwitchCount</A></B><DD>Sets the current plane switch counter to a given value.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayWaitNSwitches">GrayWaitNSwitches</A></B><DD>Waits for a given number of plane switches.</DL>
<H3><U>Constants</U></H3>
<DL INDENT="20"><DT><B><A HREF="#GRAYDBUFFER_SIZE">GRAYDBUFFER_SIZE</A></B><DD>Specifies the necessary size of a user-allocated double-buffer.</DL>
<H3><U>Predefined Types</U></H3>
<DL INDENT="20"><DT><B><A HREF="alloc.html#Bool">Bool</A></B><DD>An enumeration to describe true or false values.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayModes">GrayModes</A></B><DD>An enumeration to describe legal grayscale modes.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#GrayPlanes">GrayPlanes</A></B><DD>An enumeration to describe legal grayscale planes.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="intr.html#INT_HANDLER">INT_HANDLER</A></B><DD>A pointer to an interrupt handler.</DL>
<P>See also: <A HREF="graph.html">graph.h</A>, <A HREF="sprites.html">sprites.h</A></P>
<HR>
<H3><A NAME="GrayAdjust"><U>GrayAdjust</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayAdjust (<B><A HREF="keywords.html#short">short</A></B> adjustment);</TD></TR></TABLE></P>
<P><B>Adjusts grayscale support to make it flickerless.</B></P>

<P><B>Note:</B> This function has become more or less obsolete since the effect is hardly
visible with the new HW2 grayscale support.
<BR><BR>
This function is introduced to improve grayscale support on HW2 calculators, i.e. to make
it more flickerless (it can be used on HW1 calculators too, but HW1 grayscale support is
usually satisfactorily flickerless by default). Namely, if the plane switching frequency is
not well synchronized with the LCD refresh frequency, the flickering may be too ugly.
Unfortunately, it is not possible to use hardwired values because this frequency drifts
with the battery strength, so a value which is good if the batteries are full is not good if the
batteries are worn out, and vice versa. So the only solution is to make the frequency ratio
adjustable. This trick was used in Universal OS by Julien Muchembled to produce quite
flickerless grayscale support on HW2 calculators (many thanks to him for telling to me about
this). His grayscale support allows adjusting the LCD refresh frequency (by changing the
logical height of the display) using the keys DIAMOND+LEFT/RIGHT.
<BR><BR>
This solution was a bit unflexible to me, so I decided to use slightly modified variant of
Julien's method.
I introduced the function GrayAdjust for fine adjusting of the grayscale quality. This
function does exactly the same as pressing DIAMOND+LEFT/RIGHT in Universal OS,
i.e. it adjusts the LCD refresh frequency. The default value for <I>adjustment</I> is 0, which
means "factory settings". Values less than 0 increases and values greater than 0 decreases
the LCD refresh frequency. Legal values for <I>adjustment</I> range from -28 to 127 on
TI-89 and from 0 to 127 on TI-92+ (although only slight variations around 0 are meaningful,
for example from -10 to +10). Note that values less than 0 are not allowed on the TI-92+, else
strange things would happen with the screen (use macros from <A HREF="compat.html">compat.h</A>
to check the calculator model).
<BR><BR>
So how would one use this function? You can put an option into your program which displays
a grayscale picture, and ask the user to adjust the quality. Here is a simplified example (called "Adjust Grayscale")
of the program which displays the full screen filled with dark gray, then allows adjusting the
quality using the <CODE>'+'</CODE> and <CODE>'-'</CODE> keys (use <CODE>'ESC'</CODE> for exit):</P>
<PRE>// Adjust grayscale quality using + and - keys.

#define USE_TI89              // Compile for TI-89
#define USE_TI92PLUS          // Compile for TI-92 Plus
#define USE_V200              // Compile for V200

#define OPTIMIZE_ROM_CALLS    // Use ROM Call Optimization
#define MIN_AMS 100           // Compile for AMS 1.00 or higher
#define SAVE_SCREEN           // Save/Restore LCD Contents

#include &lt;tigcclib.h&gt;         // Include All Header Files

// Main Function
void _main(void)
{
  int key, value = 0;
  if (!GrayOn ())
    return;
  GrayAdjust (value);
  memset (GetPlane (DARK_PLANE), 255, LCD_SIZE);  // Fill the dark plane and
  memset (GetPlane (LIGHT_PLANE), 0, LCD_SIZE);   //  clear the light plane
  while ((key=ngetchx ()) != KEY_ESC)
    {
      if (key== '+' &amp;&amp; value &lt; 127)
        value++;
      if (key== '-' &amp;&amp; value &gt; (TI89 ? -28 : 0))
        value--;
      GrayAdjust(value);
    }
  GrayOff ();
}
</PRE>
<P>This program does not have to be embedded in your program: as the LCD refresh frequency is kept
in the hardware register, it will still be valid after exiting from the program, so this
example may be used as a standalone adjusting program. However, the factory
settings are restored each time the calculator is turned on. If you embed the adjustment
code in your program, it is not a bad idea to use the same adjustment key as used in
Universal OS (DIAMOND+LEFT/RIGHT), due to conformance.  These keys may be checked
easily using pseudoconstants from the <A HREF="compat.html">compat.h</A> header file, as in</P>
<PRE>if (key == KEY_DIAMOND + KEY_LEFT) ...
</PRE>
<P><B>Note:</B> Changing <I>adjustment</I>
also has influence to the lightness of the display, but you always can change the contrast
the usual way. Increasing <I>adjustment</I> makes the display lighter, and decreasing
it makes the display darker. Anyway, do not use this function for adjusting the display lightness.
Its purpose is just to estabilish precise synchronization.</P>

<HR>
<H3><A NAME="GrayCheckRunning"><U>GrayCheckRunning</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> GrayCheckRunning (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Checks whether grayscale mode is active.</B></P>

<P>GrayCheckRunning returns <A HREF="alloc.html#Bool">TRUE</A> if grayscale mode is active, else returns
<A HREF="alloc.html#Bool">FALSE</A>.</P>

<P>Deprecated alias: IsGrayMode</P>
<HR>
<H3><A NAME="GrayDBufCleanup"><U>GrayDBufCleanup</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufCleanup (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Uninitializes grayscale double-buffering.</B></P>

<P>GrayDBufCleanup turns off double-buffering mode, which should have been
previously turned on with <A HREF="#GrayDBufInit">GrayDBufInit</A>.
After calling this function, you can operate in grayscale just like before
calling <A HREF="#GrayDBufInit">GrayDBufInit</A>. You do not need to
call this function explicitly before <A HREF="#GrayOff">GrayOff</A>,
as <A HREF="#GrayOff">GrayOff</A> will perform the necessary
uninitialization itself.
<BR><BR>
<B>Note:</B> GrayDBufCleanup does <I>not</I> free the buffer passed to
<A HREF="#GrayDBufInit">GrayDBufInit</A>. You need to do this yourself
afterwards, i.e. after calling this function or
<A HREF="#GrayOff">GrayOff</A>.</P>

<P>See also: <A HREF="#GrayDBufInit">GrayDBufInit</A>, <A HREF="#GrayOff">GrayOff</A></P>
<HR>
<H3><A NAME="GrayDBufGetActiveIdx"><U>GrayDBufGetActiveIdx</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> GrayDBufGetActiveIdx (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Returns the index of the currently visible double buffer.</B></P>

<P>GrayDBufGetActiveIdx returns the index of the visible double buffer. This
index will be either 0 or 1, and can be passed to
<A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A> or
<A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A>. Usually, you
do not need to call this function directly.</P>

<P>See also: <A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A>, <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A>, <A HREF="#GrayDBufGetActivePlane">GrayDBufGetActivePlane</A>, <A HREF="#GrayDBufSetActiveAMSPlane">GrayDBufSetActiveAMSPlane</A></P>
<HR>
<H3><A NAME="GrayDBufGetActivePlane"><U>GrayDBufGetActivePlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> *GrayDBufGetActivePlane (<B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Returns a pointer to a specific plane of the currently visible buffer.</B></P>

<P>GrayDBufGetActivePlane acts like
<A HREF="#GrayGetPlane">GrayGetPlane</A> for the currently visible
buffer (it calls <A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A> with
the index returned from
<A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>). Drawing
into this buffer has (almost) direct effect on the contents of the screen.</P>

<P>See also: <A HREF="#GrayDBufGetHiddenPlane">GrayDBufGetHiddenPlane</A>, <A HREF="#GrayGetPlane">GrayGetPlane</A>, <A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A>, <A HREF="#GrayDBufToggle">GrayDBufToggle</A></P>
<HR>
<H3><A NAME="GrayDBufGetHiddenIdx"><U>GrayDBufGetHiddenIdx</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> GrayDBufGetHiddenIdx (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Returns the index of the currently invisible double buffer.</B></P>

<P>GrayDBufGetHiddenIdx returns the index of the visible double buffer. This
index will be either 0 or 1, and can be passed to
<A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A> or
<A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A>. Usually, you
do not need to call this function directly.</P>

<P>See also: <A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>, <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A>, <A HREF="#GrayDBufGetHiddenPlane">GrayDBufGetHiddenPlane</A>, <A HREF="#GrayDBufSetHiddenAMSPlane">GrayDBufSetHiddenAMSPlane</A></P>
<HR>
<H3><A NAME="GrayDBufGetHiddenPlane"><U>GrayDBufGetHiddenPlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> *GrayDBufGetHiddenPlane (<B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Returns a pointer to a specific plane of the currently hidden buffer.</B></P>

<P>GrayDBufGetHiddenPlane acts like
<A HREF="#GrayGetPlane">GrayGetPlane</A> for the currently hidden
buffer (it calls <A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A> with
the index returned from
<A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetActiveIdx</A>). Drawing
into this buffer has no effect on the contents of the screen until
<A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A> or
<A HREF="#GrayDBufToggle">GrayDBufToggle</A> is called.</P>

<P>See also: <A HREF="#GrayDBufGetActivePlane">GrayDBufGetActivePlane</A>, <A HREF="#GrayGetPlane">GrayGetPlane</A>, <A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A>, <A HREF="#GrayDBufToggle">GrayDBufToggle</A></P>
<HR>
<H3><A NAME="GrayDBufGetPlane"><U>GrayDBufGetPlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> *GrayDBufGetPlane (<B><A HREF="keywords.html#short">short</A></B> idx, <B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Returns a pointer to a specific plane of a specific buffer.</B></P>

<P>GrayDBufGetPlane acts like <A HREF="#GrayGetPlane">GrayGetPlane</A>,
but it has an additional parameter <I>idx</I> which contains the index of
the buffer for which the plane pointer should be returned. <I>idx</I> should
be 0 or 1; it is usually a value returned from
<A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A> or
<A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A>.
Usually, you do not need to call this function explicitly; call
<A HREF="#GrayDBufGetActivePlane">GrayDBufGetActivePlane</A> or
<A HREF="#GrayDBufGetHiddenPlane">GrayDBufGetHiddenPlane</A> instead.
<BR><BR>
Drawing into the currently visible buffer has (almost) direct effect on the
contents of the screen. Drawing into the hidden buffer has no effect until
<A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A> or
<A HREF="#GrayDBufToggle">GrayDBufToggle</A> is called.</P>

<P>See also: <A HREF="#GrayGetPlane">GrayGetPlane</A>, <A HREF="#GrayDBufGetActivePlane">GrayDBufGetActivePlane</A>, <A HREF="#GrayDBufGetHiddenPlane">GrayDBufGetHiddenPlane</A>, <A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>, <A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A>, <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A></P>
<HR>
<H3><A NAME="GrayDBufInit"><U>GrayDBufInit</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufInit (<B><A HREF="keywords.html#void">void</A></B> *buf);</TD></TR></TABLE></P>
<P><B>Initializes grayscale double-buffering mode.</B></P>

<P>GrayDBufInit initializes double-buffering mode. In double-buffering mode, you
can switch between two buffers (using
<A HREF="#GrayDBufToggle">GrayDBufToggle</A>) very quickly; much more
quickly than using <A HREF="mem.html#memcpy">memcpy</A> to achieve
double-buffering. This function assumes that
<A HREF="#GrayOn">GrayOn</A> has been called and its result was
successful. To have as little extra double-buffering code in the grayscale
implementation as possible, you need to allocate your own buffer and pass it
to this function. You can do this with
<A HREF="alloc.html#malloc">malloc</A>, for example, but be sure to
check its result before proceeding. The necessary size of the buffer (in
bytes) is specified by the constant
<A HREF="#GRAYDBUFFER_SIZE">GRAYDBUFFER_SIZE</A>.
<BR><BR>
You do not explicitly need to call
<A HREF="#GrayDBufCleanup">GrayDBufCleanup</A> to deactivate
double-buffering mode; <A HREF="#GrayOff">GrayOff</A> will do the
necessary uninitialization. However, be sure to free the buffer after calling
<A HREF="#GrayDBufCleanup">GrayDBufCleanup</A> or
<A HREF="#GrayOff">GrayOff</A>.
<BR><BR>
The contents of the current grayscale buffer become the new contents of the
plane with index 0 (see
<A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>). The plane
with index 1 is initialized from the new buffer and is filled either with
random contents or with zeroes, depending on the contents of <I>buf</I>. Do
not attempt to change the contents of <I>buf</I> directly after calling
GrayDBufInit.
<BR><BR>
<B>Note:</B> After calling this function, you should not use the standard
grayscale functions <A HREF="#GrayGetPlane">GrayGetPlane</A> and
<A HREF="#GraySetAMSPlane">GraySetAMSPlane</A> any more. Instead, use
the double-buffering functions
<A HREF="#GrayDBufGetPlane">GrayDBufGetPlane</A> and
<A HREF="#GrayDBufSetAMSPlane">GrayDBufSetAMSPlane</A> or related
ones.</P>

<P>See also: <A HREF="#GrayDBufCleanup">GrayDBufCleanup</A>, <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A>, <A HREF="#GrayDBufToggle">GrayDBufToggle</A></P>
<HR>
<H3><A NAME="GrayDBufSetActiveAMSPlane"><U>GrayDBufSetActiveAMSPlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufSetActiveAMSPlane (<B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Forces graphics routines to use selected plane of visible buffer.</B></P>

<P>GrayDBufSetActiveAMSPlane acts like
<A HREF="#GraySetAMSPlane">GraySetAMSPlane</A> for the currently
visible buffer (it calls
<A HREF="#GrayDBufSetAMSPlane">GrayDBufSetAMSPlane</A> with the index
returned from
<A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>). Drawing
into this buffer has (almost) direct effect on the contents of the screen.</P>

<P>See also: <A HREF="#GrayDBufSetHiddenAMSPlane">GrayDBufSetHiddenAMSPlane</A>, <A HREF="#GraySetAMSPlane">GraySetAMSPlane</A>, <A HREF="#GrayDBufSetAMSPlane">GrayDBufSetAMSPlane</A>, <A HREF="#GrayDBufToggle">GrayDBufToggle</A></P>
<HR>
<H3><A NAME="GrayDBufSetActiveIdx"><U>GrayDBufSetActiveIdx</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufSetActiveIdx (<B><A HREF="keywords.html#short">short</A></B> idx);</TD></TR></TABLE></P>
<P><B>Sets the currently visible double buffer.</B></P>

<P>GrayDBufSetActiveIdx sets the currently visible buffer to the one indexed by
<I>idx</I>, which should be either 0 or 1. Afterwards,
<A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A> will return
<I>idx</I>, and
<A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A> will return
the opposite. As the switch may happen during the time a plane is copied to
the screen, it may be desirable to use
<A HREF="#GrayDBufSetActiveIdxSync">GrayDBufSetActiveIdxSync</A>
instead.</P>

<P>See also: <A HREF="#GrayDBufSetActiveIdxSync">GrayDBufSetActiveIdxSync</A>, <A HREF="#GrayDBufToggle">GrayDBufToggle</A>, <A HREF="#GrayDBufToggleSync">GrayDBufToggleSync</A>, <A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>, <A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A></P>
<HR>
<H3><A NAME="GrayDBufSetActiveIdxSync"><U>GrayDBufSetActiveIdxSync</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufSetActiveIdxSync (<B><A HREF="keywords.html#short">short</A></B> idx);</TD></TR></TABLE></P>
<P><B>Synchronizes and sets the currently visible double buffer.</B></P>

<P>GrayDBufSetActiveIdxSync waits until the next plane switch occurs
(using <A HREF="#GrayWaitNSwitches">GrayWaitNSwitches</A>), then calls
<A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A>. This way you
can make sure that the switch is not performed during an update of the
screen, which would cause unwanted distortion effects.</P>

<P>See also: <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A>, <A HREF="#GrayDBufToggleSync">GrayDBufToggleSync</A>, <A HREF="#GrayDBufToggle">GrayDBufToggle</A>, <A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>, <A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A></P>
<HR>
<H3><A NAME="GrayDBufSetAMSPlane"><U>GrayDBufSetAMSPlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufSetAMSPlane (<B><A HREF="keywords.html#short">short</A></B> idx, <B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Forces graphics routines to use selected plane of a specific buffer.</B></P>

<P>GrayDBufSetAMSPlane acts like
<A HREF="#GraySetAMSPlane">GraySetAMSPlane</A>,
but it has an additional parameter <I>idx</I> which contains the index of
the buffer for which the plane pointer should be returned. <I>idx</I> should
be 0 or 1; it is usually a value returned from
<A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A> or
<A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A>.
Usually, you do not need to call this function explicitly; call
<A HREF="#GrayDBufSetActiveAMSPlane">GrayDBufSetActiveAMSPlane</A> or
<A HREF="#GrayDBufSetHiddenAMSPlane">GrayDBufSetHiddenAMSPlane</A>
instead.
<BR><BR>
Drawing into the currently visible buffer has (almost) direct effect on the
contents of the screen. Drawing into the hidden buffer has no effect until
<A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A> or
<A HREF="#GrayDBufToggle">GrayDBufToggle</A> is called.</P>

<P>See also: <A HREF="#GraySetAMSPlane">GraySetAMSPlane</A>, <A HREF="#GrayDBufSetActiveAMSPlane">GrayDBufSetActiveAMSPlane</A>, <A HREF="#GrayDBufSetHiddenAMSPlane">GrayDBufSetHiddenAMSPlane</A>, <A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A>, <A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A>, <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A></P>
<HR>
<H3><A NAME="GrayDBufSetHiddenAMSPlane"><U>GrayDBufSetHiddenAMSPlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufSetHiddenAMSPlane (<B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Forces graphics routines to use selected plane of hidden buffer.</B></P>

<P>GrayDBufSetHiddenAMSPlane acts like
<A HREF="#GraySetAMSPlane">GraySetAMSPlane</A> for the currently
hidden buffer (it calls
<A HREF="#GrayDBufSetAMSPlane">GrayDBufSetAMSPlane</A> with the index
returned from
<A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A>). Drawing
into this buffer has no effect on the contents of the screen until
<A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A> or
<A HREF="#GrayDBufToggle">GrayDBufToggle</A> is called.</P>

<P>See also: <A HREF="#GrayDBufSetActiveAMSPlane">GrayDBufSetActiveAMSPlane</A>, <A HREF="#GraySetAMSPlane">GraySetAMSPlane</A>, <A HREF="#GrayDBufSetAMSPlane">GrayDBufSetAMSPlane</A>, <A HREF="#GrayDBufToggle">GrayDBufToggle</A></P>
<HR>
<H3><A NAME="GrayDBufToggle"><U>GrayDBufToggle</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufToggle (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Toggles the currently visible double buffer.</B></P>

<P>GrayDBufToggle sets the currently visible buffer to the one which was
previously hidden. Afterwards, the return values of
<A HREF="#GrayDBufGetActiveIdx">GrayDBufGetActiveIdx</A> and
<A HREF="#GrayDBufGetHiddenIdx">GrayDBufGetHiddenIdx</A> will be the
exact opposite as before. As the switch may happen during the time a plane is
copied to the screen, it may be desirable to use
<A HREF="#GrayDBufToggleSync">GrayDBufToggleSync</A> instead.</P>

<P>See also: <A HREF="#GrayDBufToggleSync">GrayDBufToggleSync</A>, <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A>, <A HREF="#GrayDBufSetActiveIdxSync">GrayDBufSetActiveIdxSync</A></P>
<HR>
<H3><A NAME="GrayDBufToggleSync"><U>GrayDBufToggleSync</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayDBufToggleSync (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Synchronizes and toggles the currently visible double buffer.</B></P>

<P>GrayDBufToggleSync waits until the next plane switch occurs
(using <A HREF="#GrayWaitNSwitches">GrayWaitNSwitches</A>) and calls
<A HREF="#GrayDBufToggle">GrayDBufToggle</A>. Due to grayscale
routine implementation differences, the order of the synchronizing and
switching depends on the hardware version. On HW1, the toggles are
effective only after a plane switch, so GrayDBufToggleSync toggles first
and waits for synchronization afterwards so as to keep you from writing
into the "hidden" planes before they are actually hidden. On HW2 and higher,
GrayDBufToggleSync waits for synchronization before toggling. This way you
can make sure that the switch is not performed during an update of the
screen, which would cause unwanted distortion effects.</P>

<P>See also: <A HREF="#GrayDBufToggle">GrayDBufToggle</A>, <A HREF="#GrayDBufSetActiveIdxSync">GrayDBufSetActiveIdxSync</A>, <A HREF="#GrayDBufSetActiveIdx">GrayDBufSetActiveIdx</A></P>
<HR>
<H3><A NAME="GrayGetInt1Handler"><U>GrayGetInt1Handler</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="intr.html#INT_HANDLER">INT_HANDLER</A> GrayGetInt1Handler (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Returns the interrupt handler executed by the grayscale algorithm.</B></P>

<P>GrayGetInt1Handler returns the interrupt handler which is called internally by
the grayscale support. Use this function to store the interrupt temporarily
when you are using <A HREF="#GraySetInt1Handler">GraySetInt1Handler</A>
to change it.
<BR><BR>
The interrupt handler called by the grayscale routines looks something like this
(pseudo-code):</P>
<PRE>DEFINE_INT_HANDLER (GrayInt1Handler)
{
  SwitchPlanes ();
  ExecuteHandler (OldInt1);
}
</PRE>
<P>where <I>OldInt1</I> is the previous <A HREF="intr.html#IntVecs">AUTO_INT_1</A> handler.
GrayGetInt1Handler returns the value of <I>OldInt1</I>.
Note that this is just a C-style declaration of the <A HREF="intr.html#IntVecs">AUTO_INT_1</A>
handler for grayscale; the actual one is implemented in assembly.</P>

<P>Deprecated alias: GetGrayInt1Handler</P>
<P>See also: <A HREF="#GraySetInt1Handler">GraySetInt1Handler</A>, <A HREF="intr.html">intr.h</A></P>
<HR>
<H3><A NAME="GrayGetPlane"><U>GrayGetPlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> *GrayGetPlane (<B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Gets the address of a grayscale plane.</B></P>

<P>GrayGetPlane returns a pointer to the grayscale plane <I>plane</I>. Valid values for <I>plane</I> are
<A HREF="#GrayPlanes">LIGHT_PLANE</A> and <A HREF="#GrayPlanes">DARK_PLANE</A>.
To draw in black, draw in both planes.
<BR><BR>
<B>Note:</B> Do not assume that any plane is on 0x4C00 when in grayscale mode, due to
hardware version 2 support. Also do not assume that the 2 grayscale planes are
consecutive, this is not the case on hardware version 1.</P>

<P>Deprecated alias: GetPlane</P>
<HR>
<H3><A NAME="GrayGetSwitchCount"><U>GrayGetSwitchCount</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> GrayGetSwitchCount (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Returns the current plane switch counter.</B></P>

<P>Antediluvian versions of grayscale support were lacking a mechanism to synchronize
to the internal switching of the grayscales planes, which is quite necessary for
almost any kind of "high-speed" games where the grayscale graphics change a lot.
<BR><BR>
This is why Thomas Nussbaumer implemented a plane switch counter which is
increased after every processed plane switch.
<BR><BR>
A complete grayscale frame consists of 2 plane switches.
<A HREF="#GrayOn">GrayOn</A> resets the switch counter value to 0.
<BR><BR>
A program which wants to synchronize to the plane switching within a loop can do
this like this, for example:</P>
<PRE>unsigned long cur_count = GrayGetSwitchCount ();
do {
  unsigned long wait_for = cur_count + 2;
  while ((cur_count = GrayGetSwitchCount ()) &lt; wait_for);
  // <I>We'll always come here after the same plane</I>
  // <I>(dark plane or light plane) was switched.</I>
  
  // <I>Do something here ...</I>
  
} while (<I>some_condition</I>);
</PRE>

<P>Deprecated alias: GetGraySwitchCount</P>
<P>See also: <A HREF="#GraySetSwitchCount">GraySetSwitchCount</A></P>
<HR>
<H3><A NAME="GrayGetVersionString"><U>GrayGetVersionString</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *GrayGetVersionString (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Returns the embedded grayscale support version string.</B></P>

<P>GrayGetVersionString returns the current version of the grayscale support in
human-readable form. The version string is embedded in the program only if
this macro is used at least once.</P>

<HR>
<H3><A NAME="GrayMode"><U>GrayMode</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> GrayMode(x) ((x) ? GrayOn () : ({
<TABLE><TR><TD WIDTH="12"></TD><TD CLASS="CODE">
GrayOff ();<BR>
(<B><A HREF="keywords.html#short">short</A></B>) 1;<BR>
</TD></TR></TABLE>
}))</TD></TR></TABLE></P>
<P><B>This function has become obsolete.</B></P>

<P>This function has become obsolete. You should use <A HREF="#GrayOn">GrayOn</A> and <A HREF="#GrayOff">GrayOff</A> now.
GrayMode is implemented as a macro which calls one of these two functions; if <I>mode</I> is a constant, the compiler
will optimize the code into a single function call.</P>

<HR>
<H3><A NAME="GrayOff"><U>GrayOff</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayOff (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Deactivates grayscale mode.</B></P>

<P>This function deactivates grayscale mode. If grayscale mode is not activated,
this function does nothing.</P>

<P>See also: <A HREF="#GrayOn">GrayOn</A></P>
<HR>
<H3><A NAME="GrayOn"><U>GrayOn</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> GrayOn (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Activates grayscale mode with four shades of gray.</B></P>

<P>GrayOn activates grayscale mode. This works on both hardware version 1 and 2
calculators because the calculator type is detected automatically.
See <A HREF="#GrayAdjust">GrayAdjust</A> for information on how to reduce flickering
on HW2 calculators as much as possible.
<BR><BR>
The <A HREF="#GrayMode">GrayMode</A> function as well as the constants defined in the enum <A HREF="#GrayModes">GrayModes</A> still exist
to maintain backwards compatibility with very old programs. In fact, <A HREF="#GrayMode">GrayMode</A> is
now defined as a macro which optimizes into a call to GrayOn or <A HREF="#GrayOff">GrayOff</A> if you call it with
a constant value.
<BR><BR>
GrayOn returns <A HREF="alloc.html#Bool">FALSE</A> if there was an error in switching to grayscale
mode, otherwise it returns <A HREF="alloc.html#Bool">TRUE</A>. Don't forget to switch off grayscale mode
before your program terminates, or your TI will crash very soon!
<BR><BR>
Here is an example of a program for testing grayscale mode (called "Gray Test Project"), which displays 3 squares on the
screen, each with a different level of gray (see other functions from this header file and
from the <A HREF="graph.html">graph.h</A> header file for an explanation about how it works):</P>
<PRE>// Grayscale test program for TIGCC

#define USE_TI89
#define USE_TI92PLUS
#define USE_V200

#define MIN_AMS 100
#define SAVE_SCREEN

#include &lt;tigcclib.h&gt;

void _main(void)
{
  if (!GrayOn ())
    return;
  GraySetAMSPlane (LIGHT_PLANE);
  ClrScr ();
  ScrRectFill (&amp;(SCR_RECT){{20,20,40,40}}, ScrRect, A_NORMAL);
  ScrRectFill (&amp;(SCR_RECT){{80,20,100,40}}, ScrRect, A_NORMAL);
  GraySetAMSPlane (DARK_PLANE);
  ClrScr ();
  ScrRectFill (&amp;(SCR_RECT){{50,20,70,40}}, ScrRect, A_NORMAL);
  ScrRectFill (&amp;(SCR_RECT){{80,20,100,40}}, ScrRect, A_NORMAL);
  ngetchx ();
  GrayOff ();
}
</PRE>
<P>Starting from release 2.2 of the library, it is safe to call GrayOn
even if grayscale mode is already on, and to call <A HREF="#GrayOff">GrayOff</A>
even if grayscale mode is already off.</P>

<P>See also: <A HREF="#GrayOff">GrayOff</A>, <A HREF="#GrayOnThrow">GrayOnThrow</A></P>
<HR>
<H3><A NAME="GrayOnThrow"><U>GrayOnThrow</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayOnThrow (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Activates grayscale mode, throwing an error if unsuccessful.</B></P>

<P>GrayOnThrow works like <A HREF="#GrayOn">GrayOn</A>, except that it
throws an error if it could not turn on grayscale successfully.</P>

<P>See also: <A HREF="#GrayOn">GrayOn</A>, <A HREF="#GrayOff">GrayOff</A>, <A HREF="error.html">error.h</A></P>
<HR>
<H3><A NAME="GraySetAMSPlane"><U>GraySetAMSPlane</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GraySetAMSPlane (<B><A HREF="keywords.html#short">short</A></B> plane);</TD></TR></TABLE></P>
<P><B>Forces graphics routines to use selected plane.</B></P>

<P>GraySetAMSPlane forces all graphics routines (from <A HREF="graph.html">graph.h</A>) to draw into
the grayscale plane <I>plane</I> (valid values are <A HREF="#GrayPlanes">LIGHT_PLANE</A> and
<A HREF="#GrayPlanes">DARK_PLANE</A>). This way you can use standard routines for drawing lines, circles,
etc. in grayscale mode as well. In fact, GraySetAMSPlane is a macro which calls
<A HREF="#GrayGetPlane">GrayGetPlane</A> and <A HREF="graph.html#PortSet">PortSet</A>.</P>

<P>Deprecated alias: SetPlane</P>
<HR>
<H3><A NAME="GraySetInt1Handler"><U>GraySetInt1Handler</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GraySetInt1Handler (<A HREF="intr.html#INT_HANDLER">INT_HANDLER</A> handler);</TD></TR></TABLE></P>
<P><B>Sets the interrupt handler executed by the grayscale algorithm.</B></P>

<P>GraySetInt1Handler sets the interrupt handler which is called internally by
the grayscale support to <I>handler</I>. Using this function, you can
redirect this interrupt even in grayscale mode.
<BR><BR>
The interrupt handler called by the grayscale routines looks something like this
(pseudo-code):</P>
<PRE>DEFINE_INT_HANDLER (GrayInt1Handler)
{
  SwitchPlanes ();
  ExecuteHandler (OldInt1);
}
</PRE>
<P>where <I>OldInt1</I> is the previous <A HREF="intr.html#IntVecs">AUTO_INT_1</A> handler.
GraySetInt1Handler sets the value of <I>OldInt1</I> to <I>handler</I>.
Note that this is just a C-style declaration of the <A HREF="intr.html#IntVecs">AUTO_INT_1</A>
handler for grayscale; the actual one is implemented in assembly.
<BR><BR>
<B>Note:</B> Always reset the handler to the previous value (returned by
<A HREF="#GrayGetInt1Handler">GrayGetInt1Handler</A>) before turning
off grayscale, otherwise it will be installed as a permanent interrupt handler.</P>

<P>Deprecated alias: SetGrayInt1Handler</P>
<P>See also: <A HREF="#GrayGetInt1Handler">GrayGetInt1Handler</A>, <A HREF="intr.html">intr.h</A></P>
<HR>
<H3><A NAME="GraySetSwitchCount"><U>GraySetSwitchCount</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GraySetSwitchCount (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> val);</TD></TR></TABLE></P>
<P><B>Sets the current plane switch counter to a given value.</B></P>

<P>See <A HREF="#GrayGetSwitchCount">GrayGetSwitchCount</A> for information on the switch counter.</P>

<P>Deprecated alias: SetGraySwitchCount</P>
<P>See also: <A HREF="#GrayGetSwitchCount">GrayGetSwitchCount</A></P>
<HR>
<H3><A NAME="GrayWaitNSwitches"><U>GrayWaitNSwitches</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> GrayWaitNSwitches (<B><A HREF="keywords.html#short">short</A></B> wait);</TD></TR></TABLE></P>
<P><B>Waits for a given number of plane switches.</B></P>

<P>GrayWaitNSwitches waits for <I>wait</I> plane switches to happen before
returning. If <I>wait</I> is 1, the function waits until the next plane
switch occurs, so you can synchronize your program to the grayscale plane
switches. Since the switches happen periodically, you can be pretty sure that
no switch will occur too soon after you call this function. Using
<A HREF="#GrayGetSwitchCount">GrayGetSwitchCount</A> and
<A HREF="#GraySetSwitchCount">GraySetSwitchCount</A>, you can also
choose exactly after which plane the function returns.</P>

<P>See also: <A HREF="#GrayGetSwitchCount">GrayGetSwitchCount</A></P>
<HR>
<H3><A NAME="GRAYDBUFFER_SIZE"><U>GRAYDBUFFER_SIZE</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> GRAYDBUFFER_SIZE 7688</TD></TR></TABLE></P>
<P><B>Specifies the necessary size of a user-allocated double-buffer.</B></P>

<P>As <A HREF="#GrayDBufInit">GrayDBufInit</A> requires the user to pass
a user-allocated buffer as a parameter, this constant has been introduced to
specify the size of this buffer. Note that it is <I>not</I> exactly
<CODE>2*<A HREF="graph.html#LCD_SIZE">LCD_SIZE</A></CODE>.</P>

<HR>
<H3><A NAME="GrayModes"><U>GrayModes</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> GrayModes {GRAY_OFF = 0, GRAY_ON = 1, GRAY_HW1 = 1, GRAY_HW2 = 1};</TD></TR></TABLE></P>
<P><B>An enumeration to describe legal grayscale modes.</B></P>

<P>This type has become obsolete upon the introduction of <A HREF="#GrayOn">GrayOn</A> and <A HREF="#GrayOff">GrayOff</A>.</P>

<HR>
<H3><A NAME="GrayPlanes"><U>GrayPlanes</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#enum">enum</A></B> GrayPlanes {LIGHT_PLANE = 0, DARK_PLANE = 1};</TD></TR></TABLE></P>
<P><B>An enumeration to describe legal grayscale planes.</B></P>

<HR>
<H3><A HREF="index.html">Return to the main index</A></H3>
</BODY>
</HTML>
