<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Operators and Punctuators</TITLE>
<STYLE TYPE="TEXT/CSS">
<!--
.IE3-DUMMY { CONT-SIZE: 100%; }
BODY { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; }
P { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H1 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H2 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H3 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H4 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H5 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H6 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
UL { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #FFFFFF; }
.NOBORDER { BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.NOBORDER TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.CODE { FONT-FAMILY: Courier New; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#E0E0E0">
<FONT SIZE="5"><B>Operators and Punctuators</B></FONT>
<HR>
<UL>
<LI><B><A HREF="#allopers">List of Operators and Punctuators</A></B>
<LI><B><A HREF="#categories">Categories of Operators and Punctuators</A></B>
<LI><B><A HREF="#precedence">Precedence of Operators</A></B>
<LI><B><A HREF="#lvalue">Lvalues and Rvalues</A></B>
</UL>
<HR>
<H2><A NAME="allopers"><U>List of Operators and Punctuators</U></A></H2>
<P>The standard C language provides the following operators and punctuators:
<BR><BR>
<TABLE BORDER CELLPADDING="3" WIDTH="88%">
<TR>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#braces"></P>
<PRE>{ }</PRE>
<P></A></TD>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#subscr"></P>
<PRE>[ ]</PRE>
<P></A></TD>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#parentheses"></P>
<PRE>( )</PRE>
<P></A></TD>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#cast"></P>
<PRE>(<I>type</I>)</PRE>
<P></A></TD>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#select"></P>
<PRE><B>.</B></PRE>
<P></A></TD>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#select"></P>
<PRE>-&gt;</PRE>
<P></A></TD>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#inc"></P>
<PRE>++</PRE>
<P></A></TD>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#dec"></P>
<PRE>--</PRE>
<P></A></TD>
</TR>
<TR>
<TD ALIGN="CENTER" WIDTH="11%"><A HREF="#ref"></P>
<PRE>&amp;</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#deref"></P>
<PRE>*</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#binpm"></P>
<PRE>+</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#binpm"></P>
<PRE>-</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#complement"></P>
<PRE>~</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#logneg"></P>
<PRE>!</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="keywords.html#sizeof"></P>
<PRE>sizeof</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#mult"></P>
<PRE>/</PRE>
<P></A></TD>
</TR>
<TR>
<TD ALIGN="CENTER"><A HREF="#mult"></P>
<PRE>%</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#shift"></P>
<PRE>&lt;&lt;</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#shift"></P>
<PRE>&gt;&gt;</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#relop"></P>
<PRE>&lt;</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#relop"></P>
<PRE>&gt;</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#relop"></P>
<PRE>&lt;=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#relop"></P>
<PRE>&gt;=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#equ"></P>
<PRE>==</PRE>
<P></A></TD>
</TR>
<TR>
<TD ALIGN="CENTER"><A HREF="#equ"></P>
<PRE>!=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#logbit"></P>
<PRE>^</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#logbit"></P>
<PRE>|</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#logbit"></P>
<PRE>&amp;&amp;</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#logbit"></P>
<PRE>||</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#cond"></P>
<PRE>? :</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>*=</PRE>
<P></A></TD>
</TR>
<TR>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>/=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>%=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>+=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>-=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>&lt;&lt;=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>&gt;&gt;=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>&amp;=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>^=</PRE>
<P></A></TD>
</TR>
<TR>
<TD ALIGN="CENTER"><A HREF="#assign"></P>
<PRE>|=</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#comma"></P>
<PRE>,</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="cpp.html#SEC17"></P>
<PRE>#</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="cpp.html#SEC18"></P>
<PRE>##</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#semicolon"></P>
<PRE>;</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#colon"></P>
<PRE>:</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#quotes"></P>
<PRE>"&nbsp;"</PRE>
<P></A></TD>
<TD ALIGN="CENTER"><A HREF="#ellipsis"></P>
<PRE>...</PRE>
<P></A></TD>
</TR>
</TABLE></P>

<P>In addition, GNU C also knows the <A HREF="gnuexts.html#SEC69">typeof</A> operator, and extends
some existing operators.</P>

<HR>
<H2><A NAME="categories"><U>Categories of Operators and Punctuators</U></A></H2>
<UL>
<LI><B><A HREF="#unary">Unary operators</A></B>
<LI><B><A HREF="#binary">Binary operators</A></B>
<LI><B><A HREF="#ternary">Ternary operators</A></B>
<LI><B><A HREF="#punct">Punctuators</A></B>
</UL>
<P>The operators <A HREF="cpp.html#SEC17">#</A> and <A HREF="cpp.html#SEC18">##</A> are
used only by the <A HREF="cpp.html">preprocessor</A>.
<BR><BR>
Depending on context, the same operator can have more than one meaning. For
example, the ampersand (<CODE>'&amp;'</CODE>) can be interpreted as</P>
<UL>
<LI><P>a bitwise AND (<CODE>A &amp; B</CODE>);</P></LI>
<LI><P>an address operator (<CODE>&amp;A</CODE>);</P></LI>
</UL>
<P>In the first case, the <CODE>'&amp;'</CODE> is a unary operator; in the second, the <CODE>'&amp;'</CODE> is a
binary operator. Similarly, the comma <CODE>','</CODE> may act as an operator and as a
punctuator, etc.</P>

<H3><A NAME="unary"><U>Unary operators</U></A></H3>
<UL>
<LI><B><A HREF="#ref">Referencing operator ('&amp;')</A></B>
<LI><B><A HREF="#deref">Dereferencing operator ('*')</A></B>
<LI><B><A HREF="#unarypm">Unary plus and minus operators ('+' and '-')</A></B>
<LI><B><A HREF="#inc">Increment operator ('++')</A></B>
<LI><B><A HREF="#dec">Decrement operator ('--')</A></B>
<LI><B><A HREF="#logneg">Logical negation operator ('!')</A></B>
<LI><B><A HREF="#complement">Bitwise complement operator ('~')</A></B>
</UL>
<P><B>Note:</B> In GNU C the operator '&amp;&amp;' may also be used as unary operator for taking
<A HREF="gnuexts.html#SEC65">addresses of labels</A>.</P>

<H4><A NAME="ref"><U>Referencing operator ('&amp;')</U></A></H4>
<P>In the expression</P>
<PRE>&amp; <I>expr</I>
</PRE>
<P>which means "take the address of the <I>expr</I>",
the <I>expr</I> operand must be one of the following:</P>
<UL>
<LI><P>a function designator;</P></LI>
<LI><P>an <A HREF="#lvalue">lvalue</A> designating an object that is
not a bit field and is not declared with the register storage class specifier.</P></LI>
</UL>
<P>If the operand is of type <I>type</I>, the result is of type "pointer to <I>type</I>".
<BR><BR>
The <CODE>'&amp;'</CODE> symbol is also used in C as a binary <A HREF="#logbit">bitwise AND operator</A>.</P>

<H4><A NAME="deref"><U>Dereferencing operator ('*')</U></A></H4>
<P>In the expression</P>
<PRE>* <I>expr</I>
</PRE>
<P>which means "the object pointed to by <I>expr</I>",
the <I>expr</I> must have type "pointer to <I>type</I>," where <I>type</I> is any
data type. The result of the indirection is of type <I>type</I>.
<BR><BR>
If the operand is of type "pointer to function", the result is a function
designator. If the operand is a pointer to an object, the result is an <A HREF="#lvalue">lvalue</A>
designating that object.
<BR><BR>
In the following situations, the result of indirection is undefined:</P>
<OL>
<LI><P>The <I>expr</I> is a null pointer.</P></LI>
<LI><P>The <I>expr</I> is the address of an
automatic (local) variable and execution of its
block has terminated.</P></LI>
</OL>
<P>You can also use the asterisk as an operator to dereference a pointer, or as
the <A HREF="#mult">multiplication operator</A>. Asterisk may be used also as a
punctuator for creating <A HREF="#asterisk">pointer types</A>.</P>

<H4><A NAME="unarypm"><U>Unary plus and minus operators ('+' and '-')</U></A></H4>
<P>In these unary + - expressions</P>
<PRE>+ <I>expr</I>
- <I>expr</I>
</PRE>
<P>the <I>expr</I> operand must be of arithmetic type.
The result is the value of the operand after any required integral
promotions for the unary plus (<CODE>'+'</CODE>) operator, or
negative of the value of the operand after any
required integral promotions for the unary minus (<CODE>'-'</CODE>) operator.
Floating point negation is internally executed using the <A HREF="timath.html#fneg">fneg</A> function.
<BR><BR>
Note that both '+' and '-' operators also have a <A HREF="#binpm">binary form</A>.</P>

<H4><A NAME="inc"><U>Increment operator ('++')</U></A></H4>
<P>The increment operator may be used as a postincrement or preincrement operator:</P>
<PRE><I>expr</I> ++           (postincrement)
++ <I>expr</I>           (preincrement)
</PRE>
<P>The expression is called the operand; it must be of scalar type (arithmetic
or pointer types) and must be a modifiable <A HREF="#lvalue">lvalue</A>.
<BR><BR>
When postincrement operator form is used, the value of the whole expression is the
value of the postfix expression before the increment is applied.
After the postfix expression is evaluated, the operand is incremented by 1.
<BR><BR>
When preincrement operator form is used, the operand is incremented by 1 before the
expression is evaluated; the value of the whole expression is the incremented value
of the operand.
<BR><BR>
The increment value is appropriate to the type of the operand.
Pointer types follow the rules for pointer arithmetic. In other words, the actual
address on which a pointer points to is incremented by the size of the pointed object
(not by 1, except if the pointed object is one byte long), so after the incrementing, the
pointer points to the next object in a sequence (e.g. to a next element in an array, etc.).
<BR><BR>
<B>Note:</B> GNU C extends the pointer arithmetic to be valid even on void pointers and pointers to
functions (see <A HREF="gnuexts.html#SEC79">extended pointer arithmetic</A> for
more info).</P>

<H4><A NAME="dec"><U>Decrement operator ('--')</U></A></H4>
<P>The decrement operator may be used as a postdecrement or predecrement operator:</P>
<PRE><I>expr</I> --           (postdecrement)
-- <I>expr</I>           (predecrement)
</PRE>
<P>The decrement operator follows the same rules as the <A HREF="#inc">increment operator</A>,
except that the operand is decremented by 1 after or before the whole
expression is evaluated.</P>

<H4><A NAME="logneg"><U>Logical negation operator ('!')</U></A></H4>
<P>In the expression</P>
<PRE>! <I>expr</I>
</PRE>
<P>the <I>expr</I> operand must be of scalar type (i.e. not an array, a structure or an union).
The result is of type <CODE>int</CODE> and is the logical negation of the operand:</P>
<UL>
<LI><P>0 if the operand is nonzero;</P></LI>
<LI><P>1 if the operand is 0.</P></LI>
</UL>
<P>The expression <CODE>'!<I>expr</I>'</CODE> is equivalent to <CODE>'(0&nbsp;==&nbsp;<I>expr</I>)'</CODE>.</P>

<H4><A NAME="complement"><U>Bitwise complement operator ('~')</U></A></H4>
<P>In the expression</P>
<PRE>~ <I>expr</I>
</PRE>
<P>the <I>expr</I> operand must be of integral type. The result is the bitwise
complement of the operand after any required integral promotions.
Each 0 bit in the operand is set to 1, and each 1 bit in the operand is set to 0.</P>

<H3><A NAME="binary"><U>Binary operators</U></A></H3>
<UL>
<LI><B><A HREF="#binpm">Binary plus and minus operators ('+' and '-')</A></B>
<LI><B><A HREF="#mult">Multiplicative operators ('*', '/' and '%')</A></B>
<LI><B><A HREF="#shift">Bitwise shift operators ('&lt;&lt;' and '&gt;&gt;')</A></B>
<LI><B><A HREF="#logbit">Logical and bitwise operators ('&amp;', '^', '|', '&amp;&amp;' and '||')</A></B>
<LI><B><A HREF="#assign">Assignment operators ('=' etc.)</A></B>
<LI><B><A HREF="#relop">Relational operators ('&lt;', '&gt;', '&lt;=' and '&gt;=')</A></B>
<LI><B><A HREF="#equ">Equality operators ('==' and '!=')</A></B>
<LI><B><A HREF="#select">Selection (structure-access) operators ('.' and '-&gt;')</A></B>
</UL>
<H4><A NAME="binpm"><U>Binary plus and minus operators ('+' and '-')</U></A></H4>
<P>Both <CODE>'+'</CODE> and <CODE>'-'</CODE> uses the same syntax:</P>
<PRE><I>expr1</I> + <I>expr2</I>
<I>expr1</I> - <I>expr2</I>
</PRE>
<P>Note that both '+' and '-' operators also have an <A HREF="#unarypm">unary form</A>.
<BR><BR>
Legal operand types for <I>expr1</I> + <I>expr2</I> are:</P>
<OL>
<LI><P>Both <I>expr1</I> and <I>expr2</I> are of arithmetic type;</P></LI>
<LI><P><I>expr1</I> is of pointer to object type, and <I>expr2</I> is of integral type.</P></LI>
<LI><P><I>expr1</I> is of integral type, and <I>expr2</I> is of pointer to object type;</P></LI>
</OL>
<P>In case 1, the operands are subjected to the standard arithmetical
conversions (for example, <CODE>char</CODE>s are promoted to <CODE>int</CODE>s), and the
result is the arithmetical sum of the operands.
<BR><BR>
In cases 2 and 3, the rules of pointer arithmetic apply. When <I>expr1</I> is of
pointer type (case 2), the actual address on which a pointer points to is incremented by
<I>expr2</I> multiplied by the size of the pointed object (not just by <I>expr2</I>,
except if the pointed object is one byte long). For example, if <I>expr1</I> points
to an array, <I>expr1</I>&nbsp;+&nbsp;5 points to a fifth element of the array, no matter
how long are the particular elements of the array. The same rules are valid for the case 3.
Assuming that <I>ptr</I> is a pointer to <I>type</I> and that <I>N</I> is an integer,
and assuming that the CPU uses linear addressing (this is true on Motorola 68000, but not
on Intel 8086 for example), expression</P>
<PRE><I>ptr</I> + <I>N</I>
</PRE>
<P>is equal to</P>
<PRE>(<I>type</I> *) ((long) <I>ptr</I> + <I>N</I> * sizeof (<I>type</I>))
</PRE>
<P>Legal operand types for <I>expr1</I> - <I>expr2</I> are:</P>
<OL>
<LI><P>Both <I>expr1</I> and <I>expr2</I> are of arithmetic type;</P></LI>
<LI><P><I>expr1</I> is of pointer to object type, and <I>expr2</I> is integral type;</P></LI>
<LI><P>Both <I>expr1</I> and <I>expr2</I> are pointers to compatible object types;</P></LI>
</OL>
<P>In case 1, the operands are subjected to the standard arithmetic
conversions, and the result is the arithmetic difference of the operands.
<BR><BR>
In cases 2 and 3, the rules of pointer arithmetic apply. When <I>expr1</I> is pointer
and <I>expr2</I> is integral type (case 2), the actual address on which a pointer points to is decremented by
<I>expr2</I> multiplied by the size of the pointed object (not just by <I>expr2</I>,
except if the pointed object is one byte long). For example, if <I>expr1</I> points
to the fifth element of an array, <I>expr1</I>&nbsp;-&nbsp;2 points to a third element of the array, no matter
how long are the particular elements of the array. When both <I>expr1</I> and <I>expr2</I>
are pointers, the result of the substraction is the difference of actual addresses divided by
the common size of pointed objects. For example, if <I>expr1</I> and <I>expr2</I> point to
two elements of the same array, then <I>expr2</I>&nbsp;-&nbsp;<I>expr1</I> will be equal
to the difference of actual indices of pointed elements.
<BR><BR>
The unqualified type '<I>type</I>' is considered to be compatible with the
qualified types 'const&nbsp;<I>type</I>', 'volatile&nbsp;<I>type</I>', and
'const&nbsp;volatile&nbsp;<I>type</I>'.
<BR><BR>
Floating point addition and substraction are internally executed using the
<A HREF="timath.html#fadd">fadd</A> and <A HREF="timath.html#fsub">fsub</A> functions.
<BR><BR>
<B>Note:</B> GNU C extends the pointer arithmetic to be valid even on void pointers and pointers to
functions (see <A HREF="gnuexts.html#SEC79">extended pointer arithmetic</A> for
more info).</P>

<H4><A NAME="mult"><U>Multiplicative operators ('*', '/' and '%')</U></A></H4>
<P>There are three multiplicative operators in C:</P>
<PRE>* (multiplication: the product of the two operands)
/ (division: the quotient of the first operand divided by the second operand)
% (modulus: the remainder of the first operand divided by the second operand)
</PRE>
<P>They use the following syntax:</P>
<PRE><I>expr1</I> * <I>expr2</I>
<I>expr1</I> / <I>expr2</I>
<I>expr1</I> % <I>expr2</I>
</PRE>
<P>Note that '*' operator also has an <A HREF="#unarypm">unary form</A>, and may be also
used as a punctuator for creating <A HREF="#asterisk">pointer types</A>.
<BR><BR>
Operands for <CODE>'*'</CODE> and <CODE>'/'</CODE> are of arithmetical type, and operands of
<CODE>'%'</CODE> are of integral type.
The usual arithmetic conversions are made on the operands.
For <CODE>'/'</CODE> and <CODE>'%'</CODE>, <I>expr2</I> must be nonzero;
<I>expr2</I>&nbsp;==&nbsp;0 results in an error (you can't divide by zero).
<BR><BR>
When <I>expr1</I> and <I>expr2</I> are integers and the quotient
is not an integer:</P>
<OL>
<LI><P>If <I>expr1</I> and <I>expr2</I> have the same sign,
<I>expr1</I>&nbsp;/&nbsp;<I>expr2</I> is the largest integer less
than the true quotient, and <I>expr1</I>&nbsp;%&nbsp;<I>expr2</I>
has the sign of <I>expr1</I>.</P></LI>
<LI><P>If <I>expr1</I> and <I>expr2</I> have opposite signs,
<I>expr1</I>&nbsp;/&nbsp;<I>expr2</I> is the smallest integer greater
than the true quotient, and <I>expr1</I>&nbsp;%&nbsp;<I>expr1</I> has
the sign of <I>expr1</I>.</P></LI>
</OL>
<P><B>Note:</B> Rounding is always toward zero.
<BR><BR>
Floating point multiplication and division are internally executed using the
<A HREF="timath.html#fmul">fmul</A> and <A HREF="timath.html#fdiv">fdiv</A> functions; more detailed
info about rules of these operation is given with the description of these functions.</P>

<H4><A NAME="shift"><U>Bitwise shift operators ('&lt;&lt;' and '&gt;&gt;')</U></A></H4>
<P>Bitwise shift operators in C use the following syntax:</P>
<PRE><I>expr1</I> &lt;&lt; <I>expr2</I>
<I>expr1</I> &gt;&gt; <I>expr2</I>
</PRE>
<P>In the expressions <I>expr1</I>&nbsp;&lt;&lt;&nbsp;<I>expr2</I> and
<I>expr1</I>&nbsp;&gt;&gt;&nbsp;<I>expr2</I>, the operands <I>expr1</I>
and <I>expr2</I> must be of integral type. The normal integral promotions are performed
on <I>expr1</I> and <I>expr2</I>,
and the type of the result is the type of the promoted <I>expr1</I>.
If <I>expr2</I> is negative or is greater than or equal to the width in bits of
<I>expr1</I>, the operation is undefined.
<BR><BR>
The result of the operation <I>expr1</I>&nbsp;&lt;&lt;&nbsp;<I>expr2</I>
is the value of <I>expr1</I> left-shifted by <I>expr2</I> bit positions,
zero-filled from the right if necessary.
The result of the operation <I>expr1</I>&nbsp;&gt;&gt;&nbsp;<I>expr2</I>
is the value of <I>expr1</I> right-shifted by <I>expr2</I> bit positions.</P>

<H4><A NAME="logbit"><U>Logical and bitwise operators ('&amp;', '^', '|', '&amp;&amp;' and '||')</U></A></H4>
<P>The C language offers these bitwise and logical operators:</P>
<PRE>&amp;  (bitwise AND)
^  (bitwise exclusive OR)
|  (bitwise inclusive OR)

&amp;&amp; (logical AND)
|| (logical OR)
</PRE>
<P>They use the following syntax:</P>
<PRE><I>expr1</I> &amp; <I>expr2</I>
<I>expr1</I> ^ <I>expr2</I>
<I>expr1</I> | <I>expr2</I>
<I>expr1</I> &amp;&amp; <I>expr2</I>
<I>expr1</I> || <I>expr2</I>
</PRE>
<P>In first three expressions, both operands must be of integral type.
In fourth and fifth expressions, both operands must be of scalar type.
The usual arithmetical conversions are performed on <I>expr1</I> and <I>expr2</I>.
<BR><BR>
For the bitwise operators, each bit in the result is:
<BR><BR>
<TABLE BORDER CELLPADDING="5">
<TR><TD ALIGN="CENTER" COLSPAN="2">Bit value</TD><TD ALIGN="CENTER" COLSPAN="3">Results of</TD></TR>
<TR><TD ALIGN="CENTER">&nbsp;&nbsp;in <I>expr1</I>&nbsp;&nbsp;</TD><TD ALIGN="CENTER">&nbsp;&nbsp;in <I>expr2</I>&nbsp;&nbsp;</TD><TD ALIGN="CENTER"><I>expr1</I> &amp; <I>expr2</I></TD><TD ALIGN="CENTER"><I>expr1</I> ^ <I>expr2</I></TD><TD ALIGN="CENTER"><I>expr1</I> | <I>expr2</I></TD></TR>
<TR><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">0</TD></TR>
<TR><TD ALIGN="CENTER">1</TD><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">1</TD><TD ALIGN="CENTER">1</TD></TR>
<TR><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">1</TD><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">1</TD><TD ALIGN="CENTER">1</TD></TR>
<TR><TD ALIGN="CENTER">1</TD><TD ALIGN="CENTER">1</TD><TD ALIGN="CENTER">1</TD><TD ALIGN="CENTER">0</TD><TD ALIGN="CENTER">1</TD></TR>
</TABLE>
<BR>
Unlike the bitwise operators, <CODE>'&amp;&amp;'</CODE> and <CODE>'||'</CODE> guarantee left-to-right evaluation.
<I>expr1</I> is evaluated first; if it is zero,
<I>expr1</I>&nbsp;&amp;&amp;&nbsp;<I>expr2</I> gives 0 (false), and <I>expr2</I> is
not evaluated at all. With <I>expr1</I>&nbsp;||&nbsp;<I>expr2</I>, if
<I>expr1</I> is nonzero, <I>expr1</I>&nbsp;||&nbsp;<I>expr2</I> gives 1 (true), and
<I>expr2</I> is not evaluated at all.
<BR><BR>
<B>Note:</B> In GNU C the operator '&amp;&amp;' may be also used as unary operator for taking
<A HREF="gnuexts.html#SEC65">addresses of labels</A>.</P>

<H4><A NAME="assign"><U>Assignment operators ('=' etc.)</U></A></H4>
<P>There are 11 assignment operators in C language.
The <CODE>'='</CODE> operator is the simple assignment operator; the other 10
(<CODE>'*='</CODE>, <CODE>'/='</CODE>, <CODE>'%='</CODE>, <CODE>'+='</CODE>, <CODE>'-='</CODE>,
<CODE>'&lt;&lt;='</CODE>, <CODE>'&gt;&gt;='</CODE>, <CODE>'&amp;='</CODE>,
<CODE>'^='</CODE> and <CODE>'|='</CODE>)
are known as compound assignment operators.
All of them use the following syntax:</P>
<PRE><I>expr1</I> <I>assignment-operator</I> <I>expr2</I>
</PRE>
<P>In the expression <I>expr1</I>&nbsp;=&nbsp;<I>expr2</I>,
<I>expr1</I> must be a modifiable <A HREF="#lvalue">lvalue</A>.
The value of <I>expr2</I>, after conversion to the type of <I>expr1</I>, is
stored in the object designated by <I>expr1</I> (replacing
<I>expr1</I>'s previous value). The value of the assignment expression is the value of
<I>expr1</I> after the assignment. That's why multiple assignments like</P>
<PRE>x = y = z = 10;
a = b + 2 * (c = d - 1);
</PRE>
<P>are possible. Note that the assignment expression is not itself an lvalue.
<BR><BR>
For both simple and compound assignment, the operands <I>expr1</I> and <I>expr2</I> must obey
one of the following sets of rules:</P>
<OL>
<LI><P><I>expr1</I> is of qualified or unqualified arithmetic type and
<I>expr2</I> is of arithmetic type.</P></LI>
<LI><P><I>expr1</I> has a qualified or unqualified version
of a structure or union type compatible with the type of <I>expr2</I>.</P></LI>
<LI><P><I>expr1</I> and <I>expr2</I>
are pointers to qualified or unqualified versions of compatible types,
and the type pointed to by the left has all the qualifiers of the type pointed to
by the right.</P></LI>
<LI><P>One of <I>expr1</I> or <I>expr1</I> is a pointer to an object
or incomplete type and the other is a pointer to a qualified or unqualified
version of void. The type pointed to by the left has all the qualifiers of the type
pointed to by the right.</P></LI>
<LI><P><I>expr1</I> is a pointer and <I>expr2</I> is a null pointer constant.</P></LI>
</OL>
<P>The compound assignments are <CODE>'<I>op</I>='</CODE>, where <I>op</I> can be any one of
the ten operator symbols <CODE>'*'</CODE>, <CODE>'/'</CODE>, <CODE>'%'</CODE>, <CODE>'+'</CODE>,
<CODE>'-'</CODE>, <CODE>'&lt;&lt;'</CODE>, <CODE>'&gt;&gt;'</CODE>, <CODE>'&amp;'</CODE>,
<CODE>'^'</CODE> or <CODE>'|'</CODE>. The expression</P>
<PRE><I>expr1</I> <I>op</I>= <I>expr2</I></PRE>
<P>has the same effect as</P>
<PRE><I>expr1</I> = <I>expr1</I> <I>op</I> <I>expr2</I></PRE>
<P>except that the lvalue <I>expr1</I> is evaluated only once. For example, <I>expr1</I>&nbsp;+=&nbsp;<I>expr2</I> is
the same as <I>expr1</I>&nbsp;=&nbsp;<I>expr1</I>&nbsp;+&nbsp;<I>expr2</I>.</P>

<H4><A NAME="relop"><U>Relational operators ('&lt;', '&gt;', '&lt;=' and '&gt;=')</U></A></H4>
<P>The relational operators are used to compare relative values.
They use the following syntax:</P>
<PRE><I>expr1</I> &lt; <I>expr2</I>
<I>expr1</I> &gt; <I>expr2</I>
<I>expr1</I> &lt;= <I>expr2</I>
<I>expr1</I> &gt;= <I>expr2</I>
</PRE>
<P>In all relational expressions, the operands must conform to one of the
following sets of conditions:</P>
<OL>
<LI><P>Both <I>expr1</I> and <I>expr2</I> are of arithmetic type.
In this case, the usual arithmetic conversions are performed and the result
is of type <CODE>int</CODE>.</P></LI>
<LI><P>Both <I>expr1</I> and <I>expr1</I> are pointers to qualified or unqualified versions
of compatible object types.</P></LI>
</OL>
<P>When the operands are of arithmetic type:</P>
<UL>
<LI><P><I>expr1</I> &lt; <I>expr2</I> gives 1 (true) if the value of <I>expr1</I>
is less than value of <I>expr2</I>; otherwise, the result is 0 (false).</P></LI>
<LI><P><I>expr1</I> &lt;= <I>expr2</I> gives 1 (true) if the value of <I>expr1</I>
is less than or equal to the value of <I>expr2</I>; otherwise, the result is 0
(false).</P></LI>
<LI><P><I>expr1</I> &gt; <I>expr2</I> gives 1 (true) if the value of <I>expr1</I>
is greater than the value of <I>expr2</I>; otherwise, the result is 0 (false).</P></LI>
<LI><P><I>expr1</I> &gt;= <I>expr2</I> gives 1 (true) if the value of <I>expr1</I>
is greater than or equal to the value of <I>expr2</I>; otherwise, the result is 0 (false).</P></LI>
</UL>
<P>When the operands are of compatible pointer types,
the result depends on the relative addresses of the two
objects being pointed at.
<BR><BR>
Floating point comparisons are internally executed using the
<A HREF="timath.html#fcmp">fcmp</A> function. See the description of this function for
more info about rules of comparisons for floating point values.</P>

<H4><A NAME="equ"><U>Equality operators ('==' and '!=')</U></A></H4>
<P>The operators <CODE>'=='</CODE> and <CODE>'!='</CODE> are used to test for equality or inequality between
arithmetic or pointer values, following rules similar to those for the relational operators.
However, the equality operators have lower precedence than the relational operators,
and you can also compare certain pointer types not allowed with relational operations.
<BR><BR>
In the expressions <I>expr1</I>&nbsp;==&nbsp;<I>expr2</I> and <I>expr1</I>&nbsp;!=&nbsp;<I>expr2</I>, the operands must conform to one
of the following sets of conditions:</P>
<OL>
<LI><P>Both <I>expr1</I> and <I>expr2</I> are of arithmetic type.</P></LI>
<LI><P>Both <I>expr1</I> and <I>expr2</I> are pointers to qualified
or unqualified versions of compatible types.</P></LI>
<LI><P>One of <I>expr1</I> and <I>expr2</I> is a pointer to an
object, and the other is a pointer to a qualified or unqualified version of void.
In this case, the pointer to an object is converted to the type
of the other operand (a void pointer).</P></LI>
<LI><P>One of <I>expr1</I> or <I>expr2</I> is a pointer and the other is a null pointer constant.</P></LI>
</OL>
<P>If <I>expr1</I> and <I>expr2</I> have types that are valid operand types for a relational
operator, the same comparison rules as for the relational operators apply.
<BR><BR>
If <I>expr1</I> and <I>expr2</I> are pointers to function types, <I>expr1</I>&nbsp;==&nbsp;<I>expr2</I> gives 1 (true) if they
are both null or if they both point to the same function.
Conversely, if <I>expr1</I>&nbsp;==&nbsp;<I>expr2</I> gives 1 (true), then either <I>expr1</I> and <I>expr2</I> point to the
same function, or they are both null.
<BR><BR>
The expression <I>expr1</I>&nbsp;!=&nbsp;<I>expr2</I> follows the same rules, except that the result is 1
(true) if the operands are unequal, and 0 (false) if the operands are equal.
<BR><BR>
Floating point comparisons are internally executed using the
<A HREF="timath.html#fcmp">fcmp</A> function. See the description of this function for
more info about rules of comparisons for floating point values.</P>

<H4><A NAME="select"><U>Selection (structure-access) operators ('.' and '-&gt;')</U></A></H4>
<P>The C language supports two selection operators:</P>
<PRE>.  (direct member selector)
-&gt; (indirect, or pointer, member selector)
</PRE>
<P>You use the selection operators <CODE>'.'</CODE> and <CODE>'-&gt;'</CODE> to access structure and union
members. Suppose that the object <I>s</I> is of struct type <I>S</I> and <I>sptr</I> is a pointer to
<I>s</I>. Then, if <I>m</I> is a member identifier of type <I>M</I> declared in <I>S</I>, these
expressions:</P>
<PRE>s.m
sptr-&gt;m
</PRE>
<P>are of type <I>M</I>, and both represent the member object <I>m</I> in <I>s</I>.
<BR><BR>
The expression</P>
<PRE>sptr-&gt;m</PRE>
<P>is a convenient synonym for <CODE>(*sptr).m</CODE>.
<BR><BR>
The direct member selector (<CODE>'.'</CODE>) uses the following syntax:</P>
<PRE><I>expresssion</I> . <I>identifier</I>
</PRE>
<P>The <I>expr</I> must be of type union or structure.
The <I>identifier</I> must be the name of a member of that structure or union type.
<BR><BR>
The indirect member operator (<CODE>'-&gt;'</CODE>) uses the following syntax:</P>
<PRE><I>expr</I> -&gt; <I>identifier</I>
</PRE>
<P>The <I>expr</I> must be of type pointer to structure or pointer to union.
The <I>identifier</I> must be the name of a member of that structure or union type.
<BR><BR>
The expression with selection operators designates a member of a structure or union object. The
value of the selection expression is the value of the selected member; it will be an
<A HREF="#lvalue">lvalue</A> if and only if the <I>expr</I> is an lvalue. For example,</P>
<PRE>
struct mystruct
  {
    int i;
    char str[21];
    long d;
  } s, *sptr=&amp;s;

...

s.i = 3;              // <I>assign to the 'i' member of mystruct 's'</I>
sptr-&gt;d = 12345678;   // <I>assign to the 'd' member of mystruct 's'</I>
</PRE>
<P>The expression <CODE>'s.m'</CODE> is an lvalue, provided that <CODE>'s'</CODE> is an lvalue and
<CODE>'m'</CODE> is not an array type.
The expression <CODE>'sptr-&gt;m'</CODE> is an lvalue unless <CODE>'m'</CODE> is an array type.
<BR><BR>
If structure <I>B</I> contains a field whose type is structure <I>A</I>, the members of
<I>A</I> can be accessed by two applications of the member selectors.</P>

<H3><A NAME="ternary"><U>Ternary operators</U></A></H3>
<UL>
<LI><B><A HREF="#cond">Conditional operator ('? :')</A></B>
</UL>
<H4><A NAME="cond"><U>Conditional operator ('? :')</U></A></H4>
<P>The conditional operator <CODE>'?:'</CODE> is, in fact, a ternary operator.
It uses the following syntax:</P>
<PRE><I>expr1</I> ? <I>expr2</I> : <I>expr3</I>
</PRE>
<P>In the expression <I>expr1</I>&nbsp;?&nbsp;<I>expr2</I>&nbsp;:&nbsp;<I>Expr3</I>, the operand <I>expr1</I> must be of scalar type. The
operands <I>expr2</I> and <I>Expr3</I> must obey one of the following sets of rules:</P>
<OL>
<LI><P>Both of arithmetic type. In this case, both <I>expr2</I> and <I>Expr3</I> are subject
to the usual arithmetic conversions, and the type of the result is the common type
resulting from these conversions.</P></LI>
<LI><P>Both of compatible structure or union types.
In this case, the type of the result is the structure or union type of <I>expr2</I> and <I>expr3</I>.</P></LI>
<LI><P>Both of void type. In this case, the result is of type void.</P></LI>
<LI><P>Both of type pointer to qualified or unqualified versions of compatible types.
In this case, the type of the result is pointer to a type qualified with all the
type qualifiers of the types pointed to by both operands.</P></LI>
<LI><P>One operand of pointer type, the other a null pointer constant
In this case, the type of the result is pointer to a type qualified with all the
type qualifiers of the types pointed to by both operands.</P></LI>
<LI><P>One operand of type pointer to an object, the other of type
pointer to a qualified or unqualified version of void.
In this case, the type of the result is that of the non-pointer-to-void operand.</P></LI>
</OL>
<P>
In all cases, <I>expr1</I> is evaluated first. If its value is nonzero (true), then <I>expr2</I>
is evaluated and <I>expr3</I> is ignored (not evaluated at all). If <I>expr1</I> evaluates
to zero (false), then <I>expr3</I> is evaluated and <I>expr2</I> is ignored.
The result of <I>expr1</I>&nbsp;?&nbsp;<I>expr2</I>&nbsp;:&nbsp;<I>expr3</I> will be the value of whichever of <I>expr2</I> and
<I>expr3</I> is evaluated.
<BR><BR>
<B>Note:</B> GNU C extends the usage of the conditional operator to allow
<A HREF="gnuexts.html#SEC71">omitting the middle operand</A>, so it may be used as
a binary operator too.</P>

<H3><A NAME="punct"><U>Punctuators</U></A></H3>
<UL>
<LI><B><A HREF="#subscr">Array subscript operator ('[...]')</A></B>
<LI><B><A HREF="#parentheses">Parentheses operators ('(...)')</A></B>
<LI><B><A HREF="#braces">Braces ('{...}')</A></B>
<LI><B><A HREF="#eqsign">Equal sign ('=')</A></B>
<LI><B><A HREF="#comma">Comma operator and punctuator (',')</A></B>
<LI><B><A HREF="#semicolon">Semicolon (';')</A></B>
<LI><B><A HREF="#colon">Colon (':')</A></B>
<LI><B><A HREF="#asterisk">Asterisk ('*')</A></B>
<LI><B><A HREF="#quotes">Quotes ('&quot;...&quot;')</A></B>
<LI><B><A HREF="#ellipsis">Ellipsis ('...')</A></B>
<LI><B><A HREF="#cast">Typecast ('(type)')</A></B>
</UL>
<P>Most of these punctuators also function as operators.</P>

<H4><A NAME="subscr"><U>Array subscript operator ('[...]')</U></A></H4>
<P>Brackets indicate single and multidimensional array subscripts. When used
as an operator, the expression</P>
<PRE><I>expr1</I>[<I>expr2</I>]
</PRE>
<P>is defined exactly as</P>
<PRE>*((<I>expr1</I>) + (<I>expr2</I>))
</PRE>
<P>where either <I>expr1</I> is a pointer and <I>expr2</I> is an integer,
or <I>expr1</I> is an integer and <I>expr2</I> is a pointer. Of course,
the addition is performed in according to the pointer arithmetic rules
(see <A HREF="#binpm">binary plus</A> for more info).
<BR><BR>
Note that every array name, if used alone (without the array subscript operator), is
automatically interpreted as a pointer to the first element of the array.
<BR><BR>
When used as a punctuator, brackets are used for creating array types (see
<A HREF="#asterisk">asterisk</A> for more info).
<BR><BR>
<B>Note:</B> The GNU C extends the usage of square brackets to allow
<A HREF="gnuexts.html#SEC82">labeling elements in initializers</A>.</P>

<H4><A NAME="parentheses"><U>Parentheses operators ('(...)')</U></A></H4>
<P>Parentheses operators do the following:</P>
<UL>
<LI><P>group expressions (when necessary to change precedence);</P></LI>
<LI><P>isolate conditional expressions;</P></LI>
<LI><P>indicate function calls and function parameters.</P></LI>
</UL>
<P>Note that parentheses are also the part of the <A HREF="#cast">TypeCast</A> operator.
<BR><BR>
When used as function-call operators, parentheses use the following syntax:</P>
<PRE><I>expr</I> (<I>arg-expression-list</I>)
</PRE>
<P>This is a call to the function given by the <I>expr</I>, which can be either
the function name, or an expression which evaluates to a pointer-to-function
type. In the second case, the function call is in fact translated to</P>
<PRE>(* <I>expr</I>) (<I>arg-expression-list</I>)
</PRE>
<P><I>arg-expression-list</I> is a comma-delimited list of expressions of
any type representing the actual (or real) function arguments. The value of the
function call expression, if it has a value, is determined by the
<CODE>return</CODE> statement in the function definition.
<BR><BR>
<I>arg-expression-list</I> may even be empty, which is necessary when you
need to call an argument-less function:</P>
<PRE><I>expr</I> ()
</PRE>
<P>Note that every function name, if used alone (without the parentheses operator), is
automatically interpreted as a pointer to the function.
<BR><BR>
When used as a punctuator, parentheses are used for creating function types (see
<A HREF="#asterisk">asterisk</A> for more info).</P>

<H4><A NAME="braces"><U>Braces ('{...}')</U></A></H4>
<P>The { } braces indicate the start and end of a compound statement. Each sequence
of statements (terminated by <A HREF="#semicolon">semicolons</A>) is treated as
a single statement, called compound statement. Compound statements may have its
own local variables as well.
<BR><BR>
Braces are also used in declaration of <A HREF="keywords.html#enum">enumerations</A>,
<A HREF="keywords.html#struct">structures</A> and <A HREF="keywords.html#union">unions</A>,
as well as for function definitions. For example:</P>
<PRE>int square (int x);               // <I>This is a function prototype</I>
int square (int x) {return x*x;}  // <I>This is a function definition</I>
</PRE>
<P><B>Note:</B> The GNU C extends the usage of braces (together with <A HREF="#parentheses">parentheses</A>)
to allow making <A HREF="gnuexts.html#SEC63">statement expressions</A>. They are also used
in <A HREF="gnuexts.html#SEC81">cast constructors</A>, which are yet another
GNU C extension.</P>

<H4><A NAME="eqsign"><U>Equal sign ('=')</U></A></H4>
<P>The <CODE>'='</CODE> (equal sign) used as a punctuator separates variable declarations from initialization
lists. For example,</P>
<PRE>int array[5] = { 1, 2, 3, 4, 5 };
char *name = "Fred";
int x = 12;
</PRE>
<P>In a C function, no code can precede any variable declarations. Note that the GNU C,
in opposite to other C dialects, allow <A HREF="gnuexts.html#SEC80">non-constant
initializers</A> (like in C++).
<BR><BR>
The equal sign is also used in <A HREF="keywords.html#enum">enumerations</A>:</P>
<PRE>enum colors {Blue = 1, Red = 2, Green = 4, Light = 8};
</PRE>
<P>It is also used as the <A HREF="#assign">assignment operator</A> in expressions:</P>
<PRE>a = b + c;
</PRE>
<P>or even:</P>
<PRE>a = b + 2 * (c = d - 1);
</PRE>
<P><B>Note:</B> The GNU C extends the usage of equal sign (as a punctuator) to allow
<A HREF="gnuexts.html#SEC82">labeling elements in initializers</A>.</P>

<H4><A NAME="comma"><U>Comma operator and punctuator (',')</U></A></H4>
<P>The comma, used as a punctuator, separates the elements of a function argument list,
the elements in array or struct initializers, or the variables in a data declaration.
The comma is also used as an operator in comma expressions. Mixing the two
uses of comma is legal, but you must use parentheses to distinguish them.
<BR><BR>
When used as an operator, the comma operator uses the following syntax:</P>
<PRE><I>expr1</I>, <I>expr2</I>
</PRE>
<P>The left operand <I>expr1</I> is evaluated as a void expression
(i.e. it is ignored if not contain side effects),  then <I>expr2</I> is evaluated
to give the result and type of the comma expression. So, the result is just <I>expr2</I>.
By recursion, the expression</P>
<PRE><I>expr1</I>, <I>expr2</I>, ..., <I>ExprN</I>
</PRE>
<P>results in the left-to-right evaluation of each <I>Expr-i</I>, with the value and type
of <I>ExprN</I> giving the result of the whole expression. Comma operator is usually used
in for-loops for multiple initializations. For example,</P>
<PRE>for (i = 0, j = 1024; i + j &lt; 5; i++, j /= 2) ...
</PRE>
<P>It also may be used to avoid making compound statements in simple conditional statements.
For example,</P>
<PRE>if (x &gt; 10) i = 1, j = 2, k = 3;
</PRE>
<P>have the same effect as</P>
<PRE>if (x &gt; 10)
  {
    i = 1; j = 2; k = 3;
  }
</PRE>
<P>To avoid ambiguity with the commas used in function argument and initializer
lists, parentheses must be used. For example,</P>
<PRE>func(i, (j = 1, j + 4), k);
</PRE>
<P>calls <CODE>'func'</CODE> with three arguments, not four. The arguments are
<CODE>'i'</CODE>, <CODE>'5'</CODE>, and <CODE>'k'</CODE>.</P>

<H4><A NAME="semicolon"><U>Semicolon (';')</U></A></H4>
<P>The semicolon is a statement terminator. It is also used to separate three
expressions which are parts of a for-loop.
<BR><BR>
Any legal C expression (including the empty expression) followed by ; is
interpreted as a statement, known as an expression statement.
The expression is evaluated and its value is discarded. If the expression
statement has no side effects, it will be simply ignored.
<BR><BR>
Semicolons are often used to create an empty statement. For example, the body
of the following for-loop (which searches for a first non-zero element in the
array) is an empty statement:</P>
<PRE>for (i = 0; i &lt; max || !a[i]; i++);
</PRE>

<H4><A NAME="colon"><U>Colon (':')</U></A></H4>
<P>Use the colon (<CODE>':'</CODE>) to indicate a labeled statement:</P>
<PRE>start:
  x=0;
  ...
  goto start;
</PRE>
<P>Special case of labels are case-labels, which are used in multiple selection statements,
for example,</P>
<PRE>switch (a)
  {
    case 1:
      puts("One");
      break;
    case 2:
      puts("Two");
      break;
    ...
    default:
      puts("None of the above!");
  }
</PRE>
<P><B>Note:</B> The GNU C allows creating of <A HREF="gnuexts.html#SEC64">local labels</A>, which are
useful in macro definitions.</P>

<H4><A NAME="asterisk"><U>Asterisk ('*')</U></A></H4>
<P>The asterisk (<CODE>'*'</CODE>) in a variable expression creates a pointer to a type.
For example,</P>
<PRE>int a, *b;
</PRE>
<P>In this example <CODE>'a'</CODE> is an integer, but <CODE>'b'</CODE> is a pointer to
an integer.
<BR><BR>
Punctuators asterisk, <A HREF="#subscr">brackets</A> and <A HREF="#parentheses">parentheses</A>
may be mixed together to create very complex data types (which are sometimes very hard to
understand). When mixed together, parentheses have the greatest precedence, then brackets,
and finally, asterisks. This will be illustrated with a set of examples, which are given in
the following table:
<BR><BR>
<TABLE BORDER CELLPADDING="5">
<TR><TD VALIGN="TOP"></P>
<PRE>int x;</PRE>
<P></TD>
<TD VALIGN="TOP">A simple integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int x[5];</PRE>
<P></TD>
<TD VALIGN="TOP">An array (with 5 elements) of integers</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int x[5][6];</PRE>
<P></TD>
<TD VALIGN="TOP">An array (with 5 elements) of arrays (with 6 elements) of integers;
such "array of arrays" may be interpreted as a 5x6 matrix</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int *x;</PRE>
<P></TD>
<TD VALIGN="TOP">A pointer to an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int *x[5];</PRE>
<P></TD>
<TD VALIGN="TOP">An array of pointers to integers</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int x();</PRE>
<P></TD>
<TD VALIGN="TOP">A function (more precise, a prototype of a function) which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int x(int a);</PRE>
<P></TD>
<TD VALIGN="TOP">A function which accepts one integer argument, and which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int x(int a,int *b);</PRE>
<P></TD>
<TD VALIGN="TOP">A function which accepts two arguments, the first one is an integer, and second
one is a pointer to an integer, and which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int x(int,int*);</PRE>
<P></TD>
<TD VALIGN="TOP">The same as above, but actual names of arguments may be omitted in function
prototypes (but not in function definitions)</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int *x();</PRE>
<P></TD>
<TD VALIGN="TOP">A function which returns a pointer to an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int *x(int);</PRE>
<P></TD>
<TD VALIGN="TOP">A function which accepts one integer argument, and which returns a pointer to an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int **x;</PRE>
<P></TD>
<TD VALIGN="TOP">A pointer to a pointer to an integer (this declaration is logically equivalent
with the next one)</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int *x[];</PRE>
<P></TD>
<TD VALIGN="TOP">An array of unknown size of pointers to integers (this declaration is
logically equivalent with the previous one)</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int (*x)[5];</PRE>
<P></TD>
<TD VALIGN="TOP">A pointer to an array (with 5 elements) of integers</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int (*x)();</PRE>
<P></TD>
<TD VALIGN="TOP">A pointer to a function which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int (*x)(int,int);</PRE>
<P></TD>
<TD VALIGN="TOP">A pointer to a function which accepts two integer arguments and which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int (*x[5])();</PRE>
<P></TD>
<TD VALIGN="TOP">An array of pointers to a function which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int (*x(*x())[5])();</PRE>
<P></TD>
<TD VALIGN="TOP">A function which returns a pointer to an array of pointers to a function which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int&nbsp;(*x(*x(int))[5])(int*);</PRE>
<P></TD>
<TD VALIGN="TOP">A function which accepts one argument which is a pointer to an integer,
and which returns a pointer to an array of pointers to a function which accepts one integer
argument and which returns an integer</TD></TR>
<TR><TD VALIGN="TOP"></P>
<PRE>int (*(*x[5])())[6];</PRE>
<P></TD>
<TD VALIGN="TOP">An array (with 6 elements) of pointers to a function which returns a pointer to an array
(with 5 elements) of integers</TD></TR>
</TABLE>
<BR>
Confused? Yes, it's C!
<BR><BR>
If you simply omit the actual variable name, you will get an anonymous type. Such anonymous types
may be used with <A HREF="keywords.html#sizeof">sizeof</A> or <A HREF="#cast">typecast</A>
operators, or in lists of arguments in function prototypes. For example,
<CODE>'int*'</CODE> is anonymous pointer to an integer, <CODE>'int(*)()'</CODE> is anonymous pointer to
a function which returns an integer, and <CODE>'int(*[])(int*)'</CODE> is anonymous array (of
unknown size) of pointers to a function which returns an integer and which accepts one argument
which is a pointer to an integer.
<BR><BR>
<B>Note:</B> The GNU C extends the usage of asterisk to allow
<A HREF="gnuexts.html#SEC65">computed goto</A>.</P>

<H4><A NAME="quotes"><U>Quotes ('&quot;...&quot;')</U></A></H4>
<P>Quotes are used for defining string constants. In the compile-time, the sequence of characters
between qoutes are stored somewhere in the executable file. In the run time, the "result" of
quotes is a pointer (of type <CODE>'char*'</CODE>) which points to the place where the sequence
of characters is stored. This interpretation of quotes differs significantly from the interpretation
of strings in other languages. That's why there is nothing wrong with the following C code (it
stores the address where the text "Hello" is stored, interpreted as an integer, in <CODE>a</CODE>):</P>
<PRE>int a;
a = (int)"Hello";
</PRE>
<P>Such constructs are usually impossible in other languages. Note that sequences of characters
between quotes behave similarly like arrays declared with the <A HREF="keywords.html#static">static</A>
keyword, i.e. they can survive the end of a function or program if they are changed somewhere in
the program (anyway, it is very bad idea to change the content of a string constant). For example,
the following code</P>
<PRE>for (i = 0; i &lt; 2; i++)
  {
    char *str;
    str = "xyz";
    printf (str);
    *str = 'a';
  }
</PRE>
<P>will display "xyzayz", although it seems that "xyzxyz" would be displayed. Such strange behaviour
is caused by the fact that "xyz" is initialized in the compile-time. Now, if you understand the
correct interpretation of what the quote punctuator does, you can explain this behaviour easily.
To learn: strings in C behave quite differently than in most other languages!
<BR><BR>
<B>Note:</B> These two statements are <B>very</B> different, although most books say
that they are nearly the same:</P>
<PRE>char str[] = "Hello";
char *str = "Hello";
</PRE>
<P>Suppose that <I>str</I> is declared in the body of the function (i.e. it is an automatic
local variable). In both cases, the text "Hello" is stored somewhere in memory, and the "result"
of <CODE>"Hello"</CODE> is the address where it is stored (we will call this address <I>addr</I>).
In the first case, <I>str</I> is a local array (i.e. it is created on the stack at run
time, and there will be 6 bytes reserved for it), whose content is initialized at run-time
(because it does not exist at compile-time) with the sequence of bytes located at <I>addr</I>.
In other words, it is the same as you wrote:</P>
<PRE>char str[6];
strcpy (str, "Hello");
</PRE>
<P>The consequence is that if you change
the content of <I>str</I> (note that this is not the same as changing bytes pointed to
by <I>addr</I>), it will be reinitialized each time when this statement is encountered
again. But, in the second case, <I>str</I> is a local pointer, whose content is
initialized (at run-time) with <I>addr</I>! So, if the contents of the string "Hello" are
changed, this change will be permanent, because when this statement is encountered again,
<I>str</I> will simply be reinitialized (if changed) to <I>addr</I> but bytes
pointed to by it are not restored! Confused? See the following code:</P>
<PRE>for (i = 0; i &lt; 2; i++)
  {
    char str[] = "Hello";
    printf (str);
    str[0] = 'a';
  }
</PRE>
<P>This program will work as expected (it will display "Hello" twice). But, if you change
<CODE>'str[]'</CODE> to <CODE>'*str'</CODE>, it will not work as expected (it will
display "Hello" and then "aello").
<BR><BR>
Generally, it is a very bad idea to change strings which are the result of quotes.
The reason is that usually equal strings are stored only once in the program.
This means that you can get unexpected results if you modify them.
<BR><BR>
If the '\' character is found inside a string literal, it is threated as the start
of an escape code. Here is an incomplete list of possible escape codes:
<BR><BR>
<TABLE BORDER CELLSPACING="2" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>\\</B></TD><TD VALIGN="TOP">
Represents one <CODE>'\'</CODE> character.
</TD></TR><TR><TD VALIGN="TOP"><B>\"</B></TD><TD VALIGN="TOP">
Represents one <CODE>'"'</CODE> character. Needed in strings to represent
this character, because an unescaped <CODE>'"'</CODE> would end the string.
</TD></TR><TR><TD VALIGN="TOP"><B>\n</B></TD><TD VALIGN="TOP">
Newline; for ASCII this is octal code 012.
</TD></TR><TR><TD VALIGN="TOP"><B>\b</B></TD><TD VALIGN="TOP">
Backspace; for ASCII this is octal code 010.
</TD></TR><TR><TD VALIGN="TOP"><B>\f</B></TD><TD VALIGN="TOP">
FormFeed; for ASCII this is octal code 014.
</TD></TR><TR><TD VALIGN="TOP"><B>\r</B></TD><TD VALIGN="TOP">
Carriage-Return; for ASCII this is octal code 015.
</TD></TR><TR><TD VALIGN="TOP"><B>\t</B></TD><TD VALIGN="TOP">
Horizontal Tab; for ASCII this is octal code 011.
</TD></TR><TR><TD VALIGN="TOP"><B>\</B><I>ddd</I></TD><TD VALIGN="TOP">
An octal character code. The numeric code is 3 octal digits.
</TD></TR><TR><TD VALIGN="TOP"><B>\x</B><I>dd...</I></TD><TD VALIGN="TOP">
A hex character code. All trailing hex digits are combined.
</TD></TR>
</TABLE></P>

<H4><A NAME="ellipsis"><U>Ellipsis ('...')</U></A></H4>
<P>An ellipsis (<CODE>'...'</CODE>) consists of three successive periods with no whitespace
intervening.
You can use an ellipsis in the formal argument lists of function prototypes
to indicate a variable number of arguments, or arguments with varying types.
For example,</P>
<PRE>void func (int n, char ch, ...);
</PRE>
<P>This declaration indicates that <I>func</I> will be defined in such a way that
calls must have at least two arguments, an int and a char, but can also have
any number of additional arguments.
<BR><BR>
<B>Note:</B> The GNU C extends the usage of ellipsis for making
<A HREF="gnuexts.html#SEC83">case ranges</A> and for
<A HREF="gnuexts.html#SEC82">labeling elements in initializers</A>.</P>

<H4><A NAME="cast"><U>Typecast ('(type)')</U></A></H4>
<P>The typecast operator forces an expression to behave as an object of a given type. It uses the
following syntax:</P>
<PRE>(<I>type</I>) <I>expr</I>
</PRE>
<P>The expression <I>expr</I> will be interpreted as having type <I>type</I>. It may
be any simple type (modified or unmodified), <A HREF="keywords.html#enum">enumeration</A>,
<A HREF="keywords.html#struct">structure</A>, <A HREF="keywords.html#union">union</A>, user
defined type created using <A HREF="keywords.html#typedef">typedef</A>, <A HREF="keywords.html#void">void</A> type, or
an anonymous type (see <A HREF="#asterisk">asterisk</A> for more information about anonymous
types). Here is an example list of valid typecast operators:</P>
<PRE>(int)
(unsigned long int)
(signed)
(enum foo)
(struct foo)
(mytype)             <I>assuming that 'mytype' is defined with 'typedef'</I>
(void)
(char *)
(void *)
(struct foo *)
(void (*)(int))
(int (*[])(char*))
</PRE>
<P>Typecast operator is very powerful in C, and may be used for conversion nearly <I>everything</I>
to <I>anything</I>. For example, it is legal to convert an integer value to a pointer, so you
can perform direct access to the memory (don't do this if you don't know exactly what are you
doing). For example, <CODE>'(char*)19456'</CODE> converts integer 19456 to a char pointer, which
may be dereferenced further using the <A HREF="#deref">dereference operator</A>. So,</P>
<PRE>* (char*)19456 = 255;
</PRE>
<P>stores 255 in the memory at the absolute address 19456 (this is the first byte of the LCD memory
on TI-89 and TI-92+). The more drastic example is</P>
<PRE>((void(*)())10000)();
</PRE>
<P>which calls the subroutine located at absolute address 10000 (first, the typecast operator
<CODE>'(void(*)())'</CODE> converts 10000 to the pointer to the function, then the
<A HREF="#parentheses">parentheses</A> operator <CODE>'()'</CODE> is used to call the function).
Note that nearly the whole <A HREF="hdrindex.html">GCC4TI library</A>, when used in "nostub" mode,
is implemented using the typecast operator which converts TIOS jump table entries to pointers
to functions. For example, <A HREF="graph.html#ClrScr">ClrScr</A> is defined as
<CODE>'(*(void(**)(void))(*(long*)0xC8+0x678))'</CODE>, which is nothing other than a complex
typecast. So, when you do</P>
<PRE>ClrScr ();
</PRE>
<P>in your program, the <A HREF="cpp.html">preprocessor</A> replaces it with</P>
<PRE>(*(void(**)(void))(*(long*)0xC8+0x678))();
</PRE>
<P>However, typecast operator cannot be used to convert a scalar type to a
structure or union (and vice versa), or to convert one non-scalar type into an incompatible
non-scalar type. That's why casting to structures and unions are rarely valid.
<BR><BR>
Casting to a void means that you want to discard the result of the expression.
<BR><BR>
Casting to or from a floating point type are internally executed using the
<A HREF="timath.html#flt">flt</A> and <A HREF="timath.html#trunc">trunc</A> functions. See the description of
these functions for more info.
<BR><BR>
<B>Note:</B> GNU C extends the usage of typecast operator to allow making
<A HREF="gnuexts.html#SEC81">cast constructors</A>, which are probably the most powerful
GNU C extensions. It also allows much more flexibility in
<A HREF="gnuexts.html#SEC83">casting to an union types</A>.</P>

<HR>
<H2><A NAME="precedence"><U>Precedence of Operators</U></A></H2>
<P>In the following table of operator precedence, the C operators are
divided into 15 categories. The #1 category has the highest precedence;
category #2 (Unary operators) takes second precedence, and so on to the
Comma operator, which has lowest precedence. The operators within each
category have equal precedence.
<BR><BR>
The Unary (category #2), Conditional (category #13), and Assignment
(category #14) operators associate right-to-left; all other operators
associate left-to-right.
<BR><BR>
<TABLE BORDER CELLPADDING="5">
<TR><TD><B>Category</B></TD><TD><B>Operator</B></TD><TD><B>What it is (or does)</B></TD></TR>
<TR>
<TD VALIGN="TOP">1.&nbsp;Highest</TD>
<TD>
 [&nbsp;]<BR>
 (&nbsp;)<BR>
-&gt;<BR>
.
</TD>
<TD>
<A HREF="#subscr">Array&nbsp;subscript</A><BR>
<A HREF="#parentheses">Function&nbsp;call</A><BR>
<A HREF="#select">Indirect&nbsp;component&nbsp;selector</A><BR>
<A HREF="#select">Direct&nbsp;component&nbsp;selector</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">2.&nbsp;Unary</TD>
<TD>
!<BR>
~<BR>
+<BR>
-<BR>
++<BR>
--<BR>
&amp;<BR>
*<BR>
sizeof<BR>
(<I>type</I>)
</TD>
<TD>
<A HREF="#logneg">Logical&nbsp;negation&nbsp;(NOT)</A><BR>
<A HREF="#complement">Bitwise&nbsp;(1's)&nbsp;complement</A><BR>
<A HREF="#unarypm">Unary&nbsp;plus</A><BR>
<A HREF="#unarypm">Unary&nbsp;minus</A><BR>
<A HREF="#inc">Preincrement&nbsp;or&nbsp;postincrement</A><BR>
<A HREF="#dec">Predecrement&nbsp;or&nbsp;postdecrement</A><BR>
<A HREF="#ref">Address</A><BR>
<A HREF="#deref">Indirection</A><BR>
<A HREF="keywords.html#sizeof">Size&nbsp;of&nbsp;operand,&nbsp;in&nbsp;bytes</A><BR>
<A HREF="#cast">TypeCast</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">3.&nbsp;Multiplicative</TD>
<TD>
*<BR>
/<BR>
%<BR>
</TD>
<TD>
<A HREF="#mult">Multiply</A><BR>
<A HREF="#mult">Divide</A><BR>
<A HREF="#mult">Remainder&nbsp;(modulus)</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">4.&nbsp;Aditive</TD>
<TD>
+<BR>
-
</TD>
<TD><A HREF="#binpm">Binary&nbsp;plus</A><BR>
<A HREF="#binpm">Binary&nbsp;minus</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">5.&nbsp;Shift</TD>
<TD>
&lt;&lt;<BR>
&gt;&gt;
</TD>
<TD>
<A HREF="#shift">Shift&nbsp;left</A><BR>
<A HREF="#shift">Shift&nbsp;right</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">6.&nbsp;Relational</TD>
<TD>
&lt;<BR>
&lt;=<BR>
&gt;<BR>
&gt;=
</TD>
<TD>
<A HREF="#relop">Less&nbsp;than</A><BR>
<A HREF="#relop">Less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to</A><BR>
<A HREF="#relop">Greater&nbsp;than</A><BR>
<A HREF="#relop">Greater&nbsp;than&nbsp;or&nbsp;equal&nbsp;to</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">7.&nbsp;Equality</TD>
<TD>
==<BR>
!=
</TD>
<TD>
<A HREF="#equ">Equal&nbsp;to</A><BR>
<A HREF="#equ">Not&nbsp;equal&nbsp;to</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">8.</TD>
<TD>
&amp;
</TD>
<TD>
<A HREF="#logbit">Bitwise&nbsp;AND</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">9.</TD>
<TD>
^
</TD>
<TD>
<A HREF="#logbit">Bitwise&nbsp;XOR</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">10.</TD>
<TD>
|
</TD>
<TD>
<A HREF="#logbit">Bitwise&nbsp;OR</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">11.</TD>
<TD>
&amp;&amp;
</TD>
<TD>
<A HREF="#logbit">Logical&nbsp;AND</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">12.</TD>
<TD>
||
</TD>
<TD>
<A HREF="#logbit">Logical&nbsp;OR</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">13.&nbsp;Conditional</TD>
<TD>
?&nbsp;:
</TD>
<TD>
<A HREF="#cond">"a&nbsp;?&nbsp;x&nbsp;:&nbsp;y"&nbsp;means&nbsp;"if&nbsp;a&nbsp;then&nbsp;x,&nbsp;else&nbsp;y"</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">14.&nbsp;Assignment</TD>
<TD>=<BR>
*=<BR>
/=<BR>
%=<BR>
+=<BR>
-=<BR>
&amp;=<BR>
^=<BR>
|=<BR>
&lt;&lt;=<BR>
&gt;&gt;=
</TD>
<TD>
<A HREF="#assign">Simple&nbsp;assignment</A><BR>
<A HREF="#assign">Assign&nbsp;product</A><BR>
<A HREF="#assign">Assign&nbsp;quotient</A><BR>
<A HREF="#assign">Assign&nbsp;remainder&nbsp;(modulus)</A><BR>
<A HREF="#assign">Assign&nbsp;sum</A><BR>
<A HREF="#assign">Assign&nbsp;difference</A><BR>
<A HREF="#assign">Assign&nbsp;bitwise&nbsp;AND</A><BR>
<A HREF="#assign">Assign&nbsp;bitwise&nbsp;XOR</A><BR>
<A HREF="#assign">Assign&nbsp;bitwise&nbsp;OR</A><BR>
<A HREF="#assign">Assign&nbsp;left&nbsp;shift</A><BR>
<A HREF="#assign">Assign&nbsp;right&nbsp;shift</A>
</TD>
</TR>
<TR>
<TD VALIGN="TOP">15.&nbsp;Comma</TD>
<TD>
,
</TD>
<TD>
<A HREF="#comma">Evaluate</A>
</TD>
</TR>
</TABLE></P>

<HR>
<H2><A NAME="lvalue"><U>Lvalues and Rvalues</U></A></H2>
<P>All expressions in C language may be classified to <B>lvalues</B> and
<B>rvalues</B>.
<BR><BR>
An <B>lvalue</B> is an object locator: an expression that designates an object.
Any variable is an lvalue for example. Another example of an lvalue expression is
<CODE>'*<I>P</I>'</CODE>, where <CODE><I>P</I></CODE> is any expression evaluating
to a non-null pointer. See <A HREF="#deref">dereference operator</A> for more information.
<BR><BR>
A <B>modifiable lvalue</B> is an identifier or expression that relates to an object
that can be accessed and legally changed in memory. A const pointer to a constant, for example,
is not a modifiable lvalue. A pointer to a constant can be changed (but its dereferenced value
cannot).
<BR><BR>
Historically, the "l" stood for "left", meaning that an lvalue could legally
stand on the left (the receiving end) of an <A HREF="#assign">assignment statement</A>. Now, only
modifiable lvalues can legally stand on the left of an assignment statement.
For example, if <CODE>'a'</CODE> and <CODE>'b'</CODE> are nonconstant integer identifiers with properly
allocated memory storage, they are both modifiable lvalues, and assignments such as</P>
<PRE>a = 1;
b = a + b;
</PRE>
<P>are legal. From the other side, the expression</P>
<PRE>a + b
</PRE>
<P>is not an lvalue: <CODE>'a&nbsp;+&nbsp;b&nbsp;=&nbsp;a'</CODE> is illegal because the expression on the left is
not related to an object. Such expressions are often called rvalues (short for "right values").
<BR><BR>
<B>Note:</B> In GNU C, the class of lvalue expressions is wider than in other C dialects; see section
<A HREF="gnuexts.html#SEC70">Generalized Lvalues</A> for more info.</P>

<HR>
<H3><A HREF="index.html">Return to the main index</A></H3>
</BODY>
</HTML>
