<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<TITLE>timath.h</TITLE>
<STYLE TYPE="TEXT/CSS">
<!--
.IE3-DUMMY { CONT-SIZE: 100%; }
BODY { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; }
P { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H1 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H2 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H3 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H4 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H5 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
H6 { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
UL { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; }
TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #FFFFFF; }
.NOBORDER { BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.NOBORDER TD { FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #E0E0E0; PADDING: 0pt; }
.CODE { FONT-FAMILY: Courier New; }
-->
</STYLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#E0E0E0">
<FONT SIZE="5"><B>The &lt;timath.h&gt; Header File</B></FONT>
<HR>
<P><B>Routines for floating point arithmetic</B></P>

<H3><U>Functions</U></H3>
<DL INDENT="20"><DT><B><A HREF="stdlib.html#abs">abs</A></B><DD>Absolute value of a number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#acos">acos</A></B><DD>Floating point arc cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#acosh">acosh</A></B><DD>Floating point hyperbolic area cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#asin">asin</A></B><DD>Floating point arc sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#asinh">asinh</A></B><DD>Floating point hyperbolic area sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#atan2">atan2</A></B><DD>Four-quadrant arc tangent of y/x (or argument of the complex number).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#atan">atan</A></B><DD>Floating point arc tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#atanh">atanh</A></B><DD>Floating point hyperbolic area tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#atof">atof</A></B><DD>Converts a string to a floating point.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcd_to_float">bcd_to_float</A></B><DD>Converts BCD to float.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcd_var">bcd_var</A></B><DD>Converts reference to float object to reference to BCD object.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcdadd">bcdadd</A></B><DD>BCD addition.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcdbcd">bcdbcd</A></B><DD>Converts integer to BCD.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcdcmp">bcdcmp</A></B><DD>BCD comparation.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcddiv">bcddiv</A></B><DD>BCD division.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcdlong">bcdlong</A></B><DD>Converts BCD to integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcdmul">bcdmul</A></B><DD>BCD multiplication.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcdneg">bcdneg</A></B><DD>BCD negation.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#bcdsub">bcdsub</A></B><DD>BCD substraction.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cacos">cacos</A></B><DD>Complex arc cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cacosh">cacosh</A></B><DD>Complex hyperbolic area cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#casin">casin</A></B><DD>Complex arc sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#casinh">casinh</A></B><DD>Complex hyperbolic area sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#catan">catan</A></B><DD>Complex arc tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#catanh">catanh</A></B><DD>Complex hyperbolic area tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ccos">ccos</A></B><DD>Complex cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ccosh">ccosh</A></B><DD>Complex hyperbolic cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ceil">ceil</A></B><DD>Rounds up the floating point number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cexp">cexp</A></B><DD>Complex exponential function.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ck_valid_float">ck_valid_float</A></B><DD>Checks if the float pointed to by <I>ptr</I> is valid.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cln">cln</A></B><DD>Complex natural logarithm (base <B>e</B>).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#clog10">clog10</A></B><DD>Complex logarithm, base 10.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cos">cos</A></B><DD>Floating point cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#cosh">cosh</A></B><DD>Floating point hyperbolic cosine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#csin">csin</A></B><DD>Complex sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#csinh">csinh</A></B><DD>Complex hyperbolic sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#csqrt">csqrt</A></B><DD>Complex square root.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ctan">ctan</A></B><DD>Complex tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ctanh">ctanh</A></B><DD>Complex hyperbolic tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#exp">exp</A></B><DD>Floating point exponential function.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fabs">fabs</A></B><DD>Absolute value of a floating point number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fadd">fadd</A></B><DD>Floating point addition.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fcmp">fcmp</A></B><DD>Floating point comparation.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fdiv">fdiv</A></B><DD>Floating point division.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#M_FEXP_NEG">FEXP_NEG</A></B><DD>A deprecated macro used to define floating point numbers.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#M_FEXP">FEXP</A></B><DD>A deprecated macro used to define floating point numbers.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#float_class">float_class</A></B><DD>Determines the class of the floating point number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#float_to_bcd">float_to_bcd</A></B><DD>Converts float to BCD.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#floor">floor</A></B><DD>Rounds down the floating point number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#M_FLT_NEG">FLT_NEG</A></B><DD>A deprecated macro used to define floating point numbers.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#flt">flt</A></B><DD>Converts integer to floating point.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#M_FLT">FLT</A></B><DD>A deprecated macro used to define floating point numbers.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fmod">fmod</A></B><DD>Calculates x modulo y, i.e. the remainder of x/y.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fmul">fmul</A></B><DD>Floating point multiplication.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fneg">fneg</A></B><DD>Floating point negation.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fpisanint">fpisanint</A></B><DD>Checks whether the floating point number is reducable to an integer.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fpisodd">fpisodd</A></B><DD>Checks whether the integer part of a floating point number is an odd number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#frexp10">frexp10</A></B><DD>Splits floating point number into mantissa and exponent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#fsub">fsub</A></B><DD>Floating point substraction.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#hypot">hypot</A></B><DD>Calculates hypotenuse of right triangle.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#init_float">init_float</A></B><DD>Initializes the floating point emulator.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_float_infinity">is_float_infinity</A></B><DD>Checks whether the argument is an infinite number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_float_negative_zero">is_float_negative_zero</A></B><DD>Checks whether the argument is negative zero.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_float_positive_zero">is_float_positive_zero</A></B><DD>Checks whether the argument is positive zero.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_float_signed_infinity">is_float_signed_infinity</A></B><DD>Checks whether the argument is signed infinity.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_float_transfinite">is_float_transfinite</A></B><DD>Checks whether the argument is a transfinite number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_float_unsigned_inf_or_nan">is_float_unsigned_inf_or_nan</A></B><DD>Checks whether the argument is unsigned infinity or Not_a_Number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_float_unsigned_zero">is_float_unsigned_zero</A></B><DD>Checks whether the argument is unsigned zero.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_inf">is_inf</A></B><DD>Checks whether the argument is an infinite number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_nan">is_nan</A></B><DD>Checks whether the argument is Not_a_Number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_nzero">is_nzero</A></B><DD>Checks whether the argument is negative zero.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_pzero">is_pzero</A></B><DD>Checks whether the argument is positive zero.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_sinf">is_sinf</A></B><DD>Checks whether the argument is signed infinity.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_transfinite">is_transfinite</A></B><DD>Checks whether the argument is a transfinite number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_uinf_or_nan">is_uinf_or_nan</A></B><DD>Checks whether the argument is unsigned infinity or Not_a_Number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#is_uzero">is_uzero</A></B><DD>Checks whether the argument is unsigned zero.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#itrig">itrig</A></B><DD>Generic subroutine for calculating inverse trigonometric functions.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="stdlib.html#labs">labs</A></B><DD>Absolute value of a long integer number.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ldexp10">ldexp10</A></B><DD>Calculates x times 10 raised to exponent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#log">log</A></B><DD>Floating point natural logarithm (base <B>e</B>).<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#log10">log10</A></B><DD>Floating point logarithm, base 10.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#modf">modf</A></B><DD>Splits floating point value into integer and fraction part.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#pow">pow</A></B><DD>Floating point power function.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#round12_err">round12_err</A></B><DD>Rounds the floating point number to 12 significant digits, throwing an error if unsuccessful.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#round12">round12</A></B><DD>Rounds the floating point number to 12 significant digits.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#round14">round14</A></B><DD>Rounds the floating point number to 14 significant digits.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#sin">sin</A></B><DD>Floating point sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#sincos">sincos</A></B><DD>Calculates both sine and cosine in one turn.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#sinh">sinh</A></B><DD>Floating point hyperbolic sine.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#sqrt">sqrt</A></B><DD>Floating point square root.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#tan">tan</A></B><DD>Floating point tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#tanh">tanh</A></B><DD>Floating point hyperbolic tangent.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#trig">trig</A></B><DD>Generic subroutine for calculating trigonometric functions.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#trunc">trunc</A></B><DD>Converts floating point to integer.</DL>
<H3><U>Constants</U></H3>
<DL INDENT="20"><DT><B><A HREF="#FIVE">FIVE</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#FOUR">FOUR</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#HALF_PI">HALF_PI</A></B><DD>A constant with value <A HREF="#PI">PI</A>/2.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#HALF">HALF</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#MINUS_ONE">MINUS_ONE</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NAN">NAN</A></B><DD>A constant defining an undefined value.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NEGATIVE_INF">NEGATIVE_INF</A></B><DD>Represents an infinitely large negative quantity.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#NEGATIVE_ZERO">NEGATIVE_ZERO</A></B><DD>Represents an infinitely small quantity which is known to be always non-positive.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ONE">ONE</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#PI">PI</A></B><DD>An approximated value of pi.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#POSITIVE_INF">POSITIVE_INF</A></B><DD>Represents an infinitely large positive quantity.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A></B><DD>Represents an infinitely small quantity which is known to be always non-negative.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#TEN">TEN</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#THREE">THREE</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#TWO">TWO</A></B><DD>A deprecated constant.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#UNSIGNED_INF">UNSIGNED_INF</A></B><DD>Represents an infinite quantity.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A></B><DD>Represents an infinitely small quantity with indeterminate sign.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ZERO">ZERO</A></B><DD>A deprecated constant.</DL>
<H3><U>Predefined Types</U></H3>
<DL INDENT="20"><DT><B><A HREF="#bcd">bcd</A></B><DD>Represents the internal organization of floating point numbers
in the format recognized by the TIOS.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="alloc.html#Bool">Bool</A></B><DD>An enumeration to describe true or false values.<IMG WIDTH="1" HEIGHT="20" ALIGN="TOP"><DT><B><A HREF="#ti_float">ti_float</A></B><DD>An alias for the standard ANSI float type.</DL>
<P><B>Note:</B> All functions which return a result of type float are
implemented as macros, although many of them exist as TIOS entries. This is done
because the GCC convention for returning floating point values as function results
differs from the convention expected by the TIOS. This note is mainly unimportant from
the user's point of view.</P>

<P>See also: <A HREF="math.html">math.h</A></P>
<HR>
<H3><A NAME="acos"><U>acos</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> acos (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point arc cosine.</B></P>

<P>acos returns the arc cosine of floating point argument <I>x</I>. The result is
always in radians.
<BR><BR>
<B>Note:</B> If the argument is not in range from -1 to 1, acos will return
<A HREF="#NAN">NAN</A>.</P>

<HR>
<H3><A NAME="acosh"><U>acosh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> acosh (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point hyperbolic area cosine.</B></P>

<P>asinh returns the hyperbolic area cosine of floating point argument <I>x</I>,
Hyperbolic area cosine is defined as log(x+sqrt(x*x-1)).
<BR><BR>
<B>Note:</B> acosh will return <A HREF="#NAN">NAN</A> if <I>x</I> is smaller than 1.</P>

<HR>
<H3><A NAME="asin"><U>asin</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> asin (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point arc sine.</B></P>

<P>asin returns the arc sine of floating point argument <I>x</I>. The result is
always in radians.
<BR><BR>
<B>Note:</B> If the argument is not in range from -1 to 1, asin will return
<A HREF="#NAN">NAN</A>.</P>

<HR>
<H3><A NAME="asinh"><U>asinh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> asinh (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point hyperbolic area sine.</B></P>

<P>asinh returns the hyperbolic area sine of floating point argument <I>x</I>.
Hyperbolic area sine is defined as log(x+sqrt(x*x+1)).</P>

<HR>
<H3><A NAME="atan2"><U>atan2</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> atan2 (<B><A HREF="keywords.html#float">float</A></B> y, <B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Four-quadrant arc tangent of y/x (or argument of the complex number).</B></P>

<P>atan2 returns the four-quadrant arc tangent of <I>y</I>/<I>x</I>. More precise,
it returns the argument of the complex number <I>x</I>&nbsp;+&nbsp;<I>y</I>&nbsp;<I>i</I>.
So, the result is in the range -<I>pi</I> to <I>pi</I>.
<BR><BR>
<B>Note:</B> atan2 produces correct results even when the
resulting angle is near <I>pi</I>/2 or -<I>pi</I>/2 (<I>x</I> near
zero). If both <I>x</I> and <I>y</I> are zeros, atan2 returns <A HREF="#NAN">NAN</A>.</P>

<HR>
<H3><A NAME="atan"><U>atan</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> atan (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point arc tangent.</B></P>

<P>asin returns the arc tangent of floating point argument <I>x</I>. The result is
always in radians.</P>

<HR>
<H3><A NAME="atanh"><U>atanh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> atanh (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point hyperbolic area tangent.</B></P>

<P>atanh returns the hyperbolic area tangent of floating point argument <I>x</I>.
The hyperbolic area tangent is defined as log((1+x)/(1-x))/2.
<BR><BR>
<B>Note:</B> atanh will return <A HREF="#NAN">NAN</A> if <I>x</I> is smaller than -1
or greater than 1. Also, it will return <A HREF="#POSITIVE_INF">POSITIVE_INF</A>
if <I>x</I> is 1, and <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A> if <I>x</I> is -1.</P>

<HR>
<H3><A NAME="atof"><U>atof</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> atof (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#int">char</A></B> *s);</TD></TR></TABLE></P>
<P><B>Converts a string to a floating point.</B></P>

<P>atof converts a string pointed to by <I>s</I> to floating point value. It recognizes
the character representation of a floating point number, made up of the following:</P>
<UL>
<LI><P>an optional string of spaces;</P></LI>
<LI><P>an optional minus sign;</P></LI>
<LI><P>a string of digits and an optional decimal point (the digits can be on both
sides of the decimal point);</P></LI>
<LI><P>an optional exponent followed by a (optionally signed) integer.</P></LI>
</UL>
<P>It is important to say that this implementation of atof requires that an optional
minus sign and an optional exponent must be TI&nbsp;Basic characters for minus sign and exponent,
(characters with codes 0xAD and 0x95 instead of ordinary
'-' and 'e' or 'E' characters).
This limitation is caused by using some TIOS calls which needs such number format. Anyway,
it is very easy to "preprocess" any string to satisfy this convention before calling to
atof by routine like the following (assuming that <I>c</I> is a char variable, and <I>i</I>
is an integer variable):</P>
<PRE>for (i = 0; (c = s[i]); i++)
 // <I>Yes, the second '=' is really '=', not '=='</I>...
  {
    if (c == '-') s[i] = 0xAD;
    if ((c|32) == 'e') s[i] = 0x95;
  }
</PRE>
<P>atof returns the converted value of the input string. It returns <A HREF="#NAN">NAN</A> if the
input string cannot be converted (i.e. if it is not in a correct format). This is not the same
as in ANSI C: atof in ANSI C returns 0 if the conversion was not successful. I decided to
return <A HREF="#NAN">NAN</A> instead, so the user can check whether the conversion was
successful (which is not possible with ANSI atof). See <A HREF="#is_nan">is_nan</A> for a good
method to check whether the result is <A HREF="#NAN">NAN</A>.
<BR><BR>
<B>Note:</B> This function is not part of TIOS, and it is implemented
using the TIOS function <A HREF="estack.html#push_parse_text">push_parse_text</A>.</P>

<HR>
<H3><A NAME="bcd_to_float"><U>bcd_to_float</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> bcd_to_float (<A HREF="#bcd">bcd</A> x);</TD></TR></TABLE></P>
<P><B>Converts BCD to float.</B></P>

<P>bcd_to_float converts BCD structure <I>x</I> into an ordinary floating point value.
In fact, this function returns the same value as the argument, but with different interpretation.
This function, in a way, performs typecasting from a <A HREF="#bcd">bcd</A> type to an ordinary
<CODE>float</CODE> type.</P>

<HR>
<H3><A NAME="bcd_var"><U>bcd_var</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> bcd_var(a) (*(<A HREF="#bcd">bcd</A>*)&amp;(a))</TD></TR></TABLE></P>
<P><B>Converts reference to float object to reference to BCD object.</B></P>

<P>bcd_var converts the reference to a floating point object <I>x</I> (which must be an lvalue,
for example a floating point variable) to the reference to the same object, but interpreted
as a <A HREF="#bcd">bcd</A> structure. bcd_var is similar as <A HREF="#float_to_bcd">float_to_bcd</A>,
but returned object is an lvalue, so it may be used in assignments like</P>
<PRE>float a;
...
bcd_var(a).exponent = 0x4002;
</PRE>
<P>The drawback of bcd_var (compared with <A HREF="#float_to_bcd">float_to_bcd</A>) is the fact
that its argument must be an lvalue, so it cannot be a floating point constant or any
non-lvalue expression (for example, a result of a function).
<BR><BR>
<B>Note:</B> I used notation "&amp;bcd_var" and "&amp;x" in the prototype description, although passing
by reference and returning results by reference does not exist in ordinary C (only in C++).
However, this bcd_var is macro which is implemented on such way that it simulates
"passing and returning by reference".</P>

<HR>
<H3><A NAME="bcdadd"><U>bcdadd</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#bcd">bcd</A> bcdadd (<A HREF="#bcd">bcd</A> x, <A HREF="#bcd">bcd</A> y);</TD></TR></TABLE></P>
<P><B>BCD addition.</B></P>

<P>bcdadd is principally the same as <A HREF="#fadd">fadd</A>, but instead of
ordinary floats, its arguments and return value are <A HREF="#bcd">bcd</A>
structures (which represent internal organization of floating point values in
TIOS). At the fundamental level, bcdadd and <A HREF="#fadd">fadd</A> are the
same routine.</P>

<HR>
<H3><A NAME="bcdbcd"><U>bcdbcd</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#bcd">bcd</A> bcdbcd (<B><A HREF="keywords.html#short">long</A></B> x);</TD></TR></TABLE></P>
<P><B>Converts integer to BCD.</B></P>

<P>bcdbcd is principally the same as <A HREF="#flt">flt</A>, but instead of
ordinary float, its return value is a <A HREF="#bcd">bcd</A> structure (which
represent internal organization of floating point values in TIOS).
At the fundamental level, bcdbcd and <A HREF="#flt">flt</A> are the
same routine.</P>

<HR>
<H3><A NAME="bcdcmp"><U>bcdcmp</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">long</A></B> bcdcmp (<A HREF="#bcd">bcd</A> x, <A HREF="#bcd">bcd</A> y);</TD></TR></TABLE></P>
<P><B>BCD comparation.</B></P>

<P>bcdcmp is principally the same as <A HREF="#fcmp">fcmp</A>, but instead of
ordinary floats, its arguments are <A HREF="#bcd">bcd</A> structures (which
represent internal organization of floating point values in TIOS).
At the fundamental level, bcdcmp and <A HREF="#fcmp">fcmp</A> are the
same routine.</P>

<HR>
<H3><A NAME="bcddiv"><U>bcddiv</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#bcd">bcd</A> bcddiv (<A HREF="#bcd">bcd</A> x, <A HREF="#bcd">bcd</A> y);</TD></TR></TABLE></P>
<P><B>BCD division.</B></P>

<P>bcddiv is principally the same as <A HREF="#fdiv">fdiv</A>, but instead of
ordinary floats, its arguments and return value are <A HREF="#bcd">bcd</A>
structures (which represent internal organization of floating point values in
TIOS). At the fundamental level, bcddiv and <A HREF="#fdiv">fdiv</A> are the
same routine.</P>

<HR>
<H3><A NAME="bcdlong"><U>bcdlong</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">long</A></B> bcdlong (<A HREF="#bcd">bcd</A> x);</TD></TR></TABLE></P>
<P><B>Converts BCD to integer.</B></P>

<P>bcdlong is principally the same as <A HREF="#trunc">trunc</A>, but instead of
ordinary float, its argument is a <A HREF="#bcd">bcd</A> structure (which
represent internal organization of floating point values in TIOS).
At the fundamental level, bcdlong and <A HREF="#trunc">trunc</A> are the
same routine.</P>

<HR>
<H3><A NAME="bcdmul"><U>bcdmul</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#bcd">bcd</A> bcdmul (<A HREF="#bcd">bcd</A> x, <A HREF="#bcd">bcd</A> y);</TD></TR></TABLE></P>
<P><B>BCD multiplication.</B></P>

<P>bcdmul is principally the same as <A HREF="#fmul">fmul</A>, but instead of
ordinary floats, its arguments and return value are <A HREF="#bcd">bcd</A>
structures (which represent internal organization of floating point values in
TIOS). At the fundamental level, bcdmul and <A HREF="#fmul">fmul</A> are the
same routine.</P>

<HR>
<H3><A NAME="bcdneg"><U>bcdneg</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#bcd">bcd</A> bcdneg (<A HREF="#bcd">bcd</A> x);</TD></TR></TABLE></P>
<P><B>BCD negation.</B></P>

<P>bcdneg is principally the same as <A HREF="#fneg">fneg</A>, but instead of
ordinary floats, its argument and return value are <A HREF="#bcd">bcd</A>
structures (which represent internal organization of floating point values in
TIOS). At the fundamental level, bcdneg and <A HREF="#fneg">fneg</A> are the
same routine.</P>

<HR>
<H3><A NAME="bcdsub"><U>bcdsub</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#bcd">bcd</A> bcdsub (<A HREF="#bcd">bcd</A> x, <A HREF="#bcd">bcd</A> y);</TD></TR></TABLE></P>
<P><B>BCD substraction.</B></P>

<P>bcdsub is principally the same as <A HREF="#fsub">fsub</A>, but instead of
ordinary floats, its arguments and return value are <A HREF="#bcd">bcd</A>
structures (which represent internal organization of floating point values in
TIOS). At the fundamental level, bcdsub and <A HREF="#fsub">fsub</A> are the
same routine.</P>

<HR>
<H3><A NAME="cacos"><U>cacos</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> cacos (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex arc cosine.</B></P>

<P>cacos calculates the arc cosine w&nbsp;=&nbsp;acos(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex arc cosine is defined by
<BR><BR>
acos(z)&nbsp;=&nbsp;-<I>i</I>&nbsp;ln&nbsp;(z&nbsp;+&nbsp;<I>i</I>&nbsp;sqrt&nbsp;(1&nbsp;-&nbsp;z^2))
<BR><BR>
where <B>ln</B> and <B>sqrt</B> are complex natural
logarithm and complex square root (see <A HREF="#cln">cln</A> and
<A HREF="#csqrt">csqrt</A>).</P>

<HR>
<H3><A NAME="cacosh"><U>cacosh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> cacosh (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex hyperbolic area cosine.</B></P>

<P>cacosh calculates the hyperbolic area cosine w&nbsp;=&nbsp;acosh(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex hyperbolic area cosine is defined by
<BR><BR>
acosh(z)&nbsp;=&nbsp;ln&nbsp;(z&nbsp;+&nbsp;sqrt&nbsp;(z^2&nbsp;-&nbsp;1))
<BR><BR>
where <B>ln</B> and <B>sqrt</B> are complex natural
logarithm and complex square root (see <A HREF="#cln">cln</A> and
<A HREF="#csqrt">csqrt</A>).</P>

<HR>
<H3><A NAME="casin"><U>casin</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> casin (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex arc sine.</B></P>

<P>casin calculates the arc sine w&nbsp;=&nbsp;asin(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex arc sine is defined by
<BR><BR>
asin(z)&nbsp;=&nbsp;-<I>i</I>&nbsp;ln&nbsp;(<I>i</I>&nbsp;z&nbsp;+&nbsp;sqrt&nbsp;(1&nbsp;-&nbsp;z^2))
<BR><BR>
where <B>ln</B> and <B>sqrt</B> are complex natural
logarithm and complex square root (see <A HREF="#cln">cln</A> and
<A HREF="#csqrt">csqrt</A>).</P>

<HR>
<H3><A NAME="casinh"><U>casinh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> casinh (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex hyperbolic area sine.</B></P>

<P>casinh calculates the hyperbolic area sine w&nbsp;=&nbsp;asinh(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex hyperbolic area sine is defined by
<BR><BR>
asinh(z)&nbsp;=&nbsp;ln&nbsp;(z&nbsp;+&nbsp;sqrt&nbsp;(z^2&nbsp;+&nbsp;1))
<BR><BR>
where <B>ln</B> and <B>sqrt</B> are complex natural
logarithm and complex square root (see <A HREF="#cln">cln</A> and
<A HREF="#csqrt">csqrt</A>).</P>

<HR>
<H3><A NAME="catan"><U>catan</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> catan (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex arc tangent.</B></P>

<P>catan calculates the arc tangent w&nbsp;=&nbsp;atan(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex arc tangent is defined by
<BR><BR>
atan(z)&nbsp;=&nbsp;-<I>i</I>&nbsp;ln&nbsp;((1&nbsp;+&nbsp;<I>i</I> z)&nbsp;/&nbsp;(1&nbsp;-&nbsp;<I>i</I>&nbsp;z))&nbsp;/&nbsp;2
<BR><BR>
where <B>ln</B> is complex natural
logarithm  (see <A HREF="#cln">cln</A>).</P>

<HR>
<H3><A NAME="catanh"><U>catanh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> catanh (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex hyperbolic area tangent.</B></P>

<P>catanh calculates the hyperbolic area tangent w&nbsp;=&nbsp;atanh(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex hyperbolic area tangent is defined by
<BR><BR>
atanh(z)&nbsp;=&nbsp;ln&nbsp;((1&nbsp;+&nbsp;z)&nbsp;/&nbsp;(1&nbsp;-&nbsp;z))&nbsp;/&nbsp;2
<BR><BR>
where <B>ln</B> is complex natural logarithm
(see <A HREF="#cln">cln</A>).</P>

<HR>
<H3><A NAME="ccos"><U>ccos</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> ccos (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex cosine.</B></P>

<P>ccos calculates the cosine w&nbsp;=&nbsp;cos(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex cosine is defined by
<BR><BR>
cos(z)&nbsp;=&nbsp;(exp(<I>i</I>&nbsp;z)&nbsp;+&nbsp;exp(-<I>i</I>&nbsp;z))&nbsp;/&nbsp;2
<BR><BR>
where <B>exp</B> is complex exponential function
(see <A HREF="#cexp">cexp</A>).</P>

<HR>
<H3><A NAME="ccosh"><U>ccosh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> ccosh (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex hyperbolic cosine.</B></P>

<P>ccosh calculates the hyperbolic cosine w&nbsp;=&nbsp;cosh(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex hyperbolic cosine is defined by
<BR><BR>
cosh(z)&nbsp;=&nbsp;(exp(z)&nbsp;+&nbsp;exp(-z))&nbsp;/&nbsp;2
<BR><BR>
where <B>exp</B> is complex exponential function
(see <A HREF="#cexp">cexp</A>).</P>

<HR>
<H3><A NAME="ceil"><U>ceil</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> ceil (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Rounds up the floating point number.</B></P>

<P>ceil finds the smallest integer not less than floating point argument <I>x</I>,
and returns the integer found as a floating point value.</P>

<HR>
<H3><A NAME="cexp"><U>cexp</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> cexp (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex exponential function.</B></P>

<P>cexp calculates the complex exponential function w&nbsp;=&nbsp;exp(z) of the complex
number which real and imaginary parts are <I>z_re</I> and
<I>z_im</I>, and stores real and imaginary part of the result
in floating point destinations pointed to by <I>w_re</I> and
<I>w_im</I>. The complex exponential function is defined by
<BR><BR>
exp(z)&nbsp;=&nbsp;exp(z_re)&nbsp;(cos(z_im)&nbsp;+&nbsp;<I>i</I>&nbsp;sin(z_im))
<BR><BR>
See <A HREF="#exp">exp</A>, <A HREF="#sin">sin</A> and <A HREF="#cos">cos</A>.</P>

<HR>
<H3><A NAME="ck_valid_float"><U>ck_valid_float</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> ck_valid_float (<B><A HREF="keywords.html#float">float</A></B> *ptr);</TD></TR></TABLE></P>
<P><B>Checks if the float pointed to by <I>ptr</I> is valid.</B></P>

<P>This function first rounds *ptr to 14 significant digits and underflows it to 0 if the exponent is less than -999 (it 
returns TRUE in that case). If the float pointed to by ptr is transfinite (see is_float_transfinite) or its exponent is 
greater than +999, *ptr is set to NAN and FALSE is returned. Else, TRUE is returned.</P>

<HR>
<H3><A NAME="cln"><U>cln</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> cln (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex natural logarithm (base <B>e</B>).</B></P>

<P>cln calculates the natural logarithm w&nbsp;=&nbsp;ln(z) of the complex
number which real and imaginary parts are <I>z_re</I> and
<I>z_im</I>, and stores real and imaginary part of the result
in floating point destinations pointed to by <I>w_re</I> and
<I>w_im</I>. The complex logarithm is defined by
<BR><BR>
ln(z)&nbsp;=&nbsp;log(abs(z))&nbsp;+&nbsp;<I>i</I>&nbsp;arg(z)
<BR><BR>
where abs(z)&nbsp;=&nbsp;sqrt(z_re^2+z_im^2), arg(z)&nbsp;=&nbsp;atan2(z_im, z_re)
and <A HREF="#log">log</A> is the real natural logarithm. See
also <A HREF="#sqrt">sqrt</A> and <A HREF="#atan2">atan2</A>.</P>

<HR>
<H3><A NAME="clog10"><U>clog10</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> clog10 (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex logarithm, base 10.</B></P>

<P>clog10 calculates the base 10 logarithm w&nbsp;=&nbsp;log10(z) of the complex
number which real and imaginary parts are <I>z_re</I> and
<I>z_im</I>, and stores real and imaginary part of the result
in floating point destinations pointed to by <I>w_re</I> and
<I>w_im</I>. The base 10 complex logarithm is defined by
<BR><BR>
log10(z)&nbsp;=&nbsp;ln(z)&nbsp;/&nbsp;ln(10)
<BR><BR>
where <B>ln</B> is complex natural logarithm
(see <A HREF="#cln">cln</A>).</P>

<HR>
<H3><A NAME="cos"><U>cos</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> cos (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point cosine.</B></P>

<P>cos returns the cosine of floating point argument <I>x</I>, which is assumed
to be specified in radians.
<BR><BR>
<B>Note:</B> cos will return <A HREF="#NAN">NAN</A> if the argument is so big that
reducing to the main period can't be performed without complete losing of
significant digits (i.e. when the magnitude of <I>x</I> is greater than 1e13).</P>

<HR>
<H3><A NAME="cosh"><U>cosh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> cosh (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point hyperbolic cosine.</B></P>

<P>sinh returns the hyperbolic cosine of floating point argument <I>x</I>.
Hyperbolic cosine is defined as (exp(x)+exp(-x))/2.
<BR><BR>
<B>Note:</B> cosh will return <A HREF="#POSITIVE_INF">POSITIVE_INF</A>
in a case of overflow.</P>

<HR>
<H3><A NAME="csin"><U>csin</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> csin (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex sine.</B></P>

<P>csin calculates the sine w&nbsp;=&nbsp;sin(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex sine is defined by
<BR><BR>
sin(z)&nbsp;=&nbsp;(exp(<I>i</I>&nbsp;z)&nbsp;-&nbsp;exp(-<I>i</I>&nbsp;z))&nbsp;/&nbsp;(2&nbsp;<I>i</I>)
<BR><BR>
where <B>exp</B> is complex exponential function
(see <A HREF="#cexp">cexp</A>).</P>

<HR>
<H3><A NAME="csinh"><U>csinh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> csinh (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex hyperbolic sine.</B></P>

<P>csinh calculates the hyperbolic sine w&nbsp;=&nbsp;sinh(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex hyperbolic sine is defined by
<BR><BR>
sinh(z)&nbsp;=&nbsp;(exp(z)&nbsp;-&nbsp;exp(-z))&nbsp;/&nbsp;2
<BR><BR>
where <B>exp</B> is complex exponential function
(see <A HREF="#cexp">cexp</A>).</P>

<HR>
<H3><A NAME="csqrt"><U>csqrt</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> csqrt (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex square root.</B></P>

<P>csqrt calculates the square root w&nbsp;=&nbsp;sqrt(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex square root is defined by
<BR><BR>
sqrt(z)&nbsp;=&nbsp;sqrt(abs(z))&nbsp;(cos(arg(z)/2)&nbsp;+&nbsp;<I>i</I>&nbsp;sin(arg(z)/2))
<BR><BR>
where abs(z)&nbsp;=&nbsp;sqrt(z_re^2+z_im^2) and arg(z)&nbsp;=&nbsp;atan2(z_im, z_re).
See <A HREF="#sqrt">sqrt</A>, <A HREF="#atan2">atan2</A>,
<A HREF="#sin">sin</A> and <A HREF="#cos">cos</A>.</P>

<HR>
<H3><A NAME="ctan"><U>ctan</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> ctan (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex tangent.</B></P>

<P>ctan calculates the tangent w&nbsp;=&nbsp;tan(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex tangent is defined by
<BR><BR>
tan(z)&nbsp;=&nbsp;sin(z)&nbsp;/&nbsp;cos(z)
<BR><BR>
where <B>sin</B> and <B>cos</B> are complex sine and
complex cosine (see <A HREF="#csin">csin</A> and <A HREF="#ccos">ccos</A>).</P>

<HR>
<H3><A NAME="ctanh"><U>ctanh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> ctanh (<B><A HREF="keywords.html#float">float</A></B> z_re, <B><A HREF="keywords.html#float">float</A></B> z_im, <B><A HREF="keywords.html#float">float</A></B> *w_re, <B><A HREF="keywords.html#float">float</A></B> *w_im);</TD></TR></TABLE></P>
<P><B>Complex hyperbolic tangent.</B></P>

<P>ctanh calculates the hyperbolic tangent w&nbsp;=&nbsp;tanh(z) of the complex number which real and
imaginary parts are <I>z_re</I> and <I>z_im</I>, and stores real and
imaginary part of the result in floating point destinations pointed to by
<I>w_re</I> and <I>w_im</I>. The complex hyperbolic tangent is defined by
<BR><BR>
tanh(z)&nbsp;=&nbsp;sinh(z)&nbsp;/&nbsp;cosh(z)
<BR><BR>
where <B>sinh</B> and <B>cosh</B> are complex hyperbolic
sine and complex hyperbolic cosine (see <A HREF="#csinh">csinh</A> and
<A HREF="#ccosh">ccosh</A>).</P>

<HR>
<H3><A NAME="exp"><U>exp</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> exp (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point exponential function.</B></P>

<P>exp returns the exponential function of floating point argument <I>x</I>
(i.e. calculates <B>e</B> to the <I>x</I>-th power).
<BR><BR>
<B>Note:</B> exp will return <A HREF="#POSITIVE_INF">POSITIVE_INF</A> in a case of overflow, and
zero (unsigned, see <A HREF="#ZERO">ZERO</A>; strange, I expected
<A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>) in a case of underflow.</P>

<HR>
<H3><A NAME="fabs"><U>fabs</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> fabs (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Absolute value of a floating point number.</B></P>

<P>fabs returns the absolute value of floating point argument <I>x</I>.</P>

<P>See also: <A HREF="stdlib.html#abs">abs</A>, <A HREF="stdlib.html#labs">labs</A></P>
<HR>
<H3><A NAME="fadd"><U>fadd</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> fadd (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Floating point addition.</B></P>

<P>fadd returns the sum of floating point arguments <I>x</I> and <I>y</I>.
This routine performs the same operation as the C <CODE>'+'</CODE> operator applied to floating
point operands, but it is kept here for backwards compatibility.
At the fundamental level, fadd is exactly the same routine as
<A HREF="#bcdadd">bcdadd</A>.</P>

<HR>
<H3><A NAME="fcmp"><U>fcmp</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">long</A></B> fcmp (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Floating point comparation.</B></P>

<P>fcmp compares floating point arguments <I>x</I> and <I>y</I>, and returns a
value which is</P>
<UL>
<LI><P>&lt; 0 if <I>x</I> is less than <I>y</I></P></LI>
<LI><P>== 0 if <I>x</I> is the same as <I>y</I></P></LI>
<LI><P>&gt; 0 if <I>x</I> is greater than <I>y</I></P></LI>
</UL>
<P>This function may be useful as a comparison function for <A HREF="stdlib.html#qsort">qsort</A>
function from <A HREF="stdlib.html">stdlib.html</A>. All relation operators applied to
floating point types are implemented through implicite calls of this function.
At the fundamental level, fcmp is exactly the same routine as
<A HREF="#bcdcmp">bcdcmp</A>.
<BR><BR>
<B>Note:</B> All kind of zeros are equal from the aspect of comparation. Transfinite values
are incomparable, and the result of fcmp is unpredictable (usually 1, but this is not
guarantee) if any argument is transfinite. See <A HREF="#ZERO">ZERO</A>,
<A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A>, <A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>,
<A HREF="#NEGATIVE_ZERO">NEGATIVE_ZERO</A>, <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>,
<A HREF="#POSITIVE_INF">POSITIVE_INF</A>, <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>
and <A HREF="#NAN">NAN</A> for more details.</P>

<HR>
<H3><A NAME="fdiv"><U>fdiv</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> fdiv (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Floating point division.</B></P>

<P>fdiv returns the quotient of floating point arguments <I>x</I> and <I>y</I>.
This routine performs the same operation as the C <CODE>'/'</CODE> operator applied to floating
point operands, but it is kept here for backwards compatibility.
At the fundamental level, fdiv is exactly the same routine as
<A HREF="#bcddiv">bcddiv</A>.
<BR><BR>
<B>Note:</B> fdiv returns infinite result
if the argument is zero (signed or unsigned), or in a case of overflow.
Also, it returns <A HREF="#NAN">NAN</A> if both arguments are zeros
or infinities.
See <A HREF="#ZERO">ZERO</A>, <A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A>,
<A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>, <A HREF="#NEGATIVE_ZERO">NEGATIVE_ZERO</A>,
<A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>, <A HREF="#POSITIVE_INF">POSITIVE_INF</A> and
<A HREF="#NEGATIVE_INF">NEGATIVE_INF</A> for more details.</P>

<HR>
<H3><A NAME="M_FEXP_NEG"><U>FEXP_NEG</U></A></H3>
<P><B>A deprecated macro used to define floating point numbers.</B></P>

<P>FEXP_NEG (also deprecated) works exactly like
<A HREF="#M_FEXP">FEXP</A>, except it constructs negative values
instead of positive ones.</P>

<HR>
<H3><A NAME="M_FEXP"><U>FEXP</U></A></H3>
<P><B>A deprecated macro used to define floating point numbers.</B></P>

<P>Yet one deprecated macro. <CODE>FEXP(<I>m</I>,<I>e</I>)</CODE> constructs
a number <CODE><I>m</I>*10^<I>e</I></CODE> where <I>m</I> is a sequence
of digits (without decimal point) which is assumed to represent decimal number
<I>m.mmmm...</I>, e.g. <CODE>FEXP(2514,5)</CODE> represents number
<CODE>2.514*10^5</CODE> (<CODE>251400</CODE> or <CODE>2.514e5</CODE> using
conventional exponential notation), and <CODE>FEXP(42,-3)</CODE> represents
number <CODE>4.2*10^-3</CODE> (<CODE>0.0042</CODE> or <CODE>4.2e-3</CODE>).
<CODE>FEXP(1,3)</CODE> is <CODE>1*10^3</CODE> (<CODE>1000</CODE> or <CODE>1e3</CODE>).
<I>mantissa</I> must be the constant sequence of digits, without leading zeros,
but the way on which <CODE>FEXP</CODE> is implemented allows that
<I>exponent</I> may be a variable or an expression, like
<CODE>FEXP(314,a)</CODE>, when even <I>mantissa</I> is not a constant, you
can use function <A HREF="#ldexp10">ldexp10</A>. Anyway, you don't need to
use <CODE>FEXP</CODE> any more: simply use conventional exponential notation.
E.g. simply use <CODE>4.2e3</CODE> instead of <CODE>FEXP(42,3)</CODE> etc.
<BR><BR>
Note that <CODE>a&nbsp;=&nbsp;FEXP(<I>m</I>,<I>e</I>)</CODE> is not the same as
<CODE>bcd_var(a).exponent&nbsp;=&nbsp;<I>e</I>+0x4000</CODE>
and <CODE>bcd_var(a).mantissa&nbsp;=&nbsp;<I>m</I></CODE>. The first part is
true; the second is not. More precise, <CODE>FEXP</CODE> shifts <I>m</I> to
the left enough number of times to produce correct normalized mantissa (see
<A HREF="#bcd">bcd</A> for more info).
So, when you type <CODE>a&nbsp;=&nbsp;FEXP(352,3)</CODE> it works like
<CODE>bcd_var(a).exponent&nbsp;=&nbsp;0x4003</CODE>
and <CODE>bcd_var(a).mantissa&nbsp;=&nbsp;0x3520000000000000</CODE>.
For more description about internal format of
floating point numbers, see <A HREF="#bcd">bcd</A>.</P>

<P>See also: <A HREF="#float_to_bcd">float_to_bcd</A>, <A HREF="#bcd_to_float">bcd_to_float</A>, <A HREF="#bcd_var">bcd_var</A></P>
<HR>
<H3><A NAME="float_class"><U>float_class</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> float_class (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Determines the class of the floating point number.</B></P>

<P>float_class checks the floating point argument <I>x</I> and returns an integer
result which determines the subtype of the argument, in according to the
following table:
<BR><BR>
<TABLE BORDER CELLPADDING="3">
<TR><TD>1</TD><TD>Not_a_Number (<A HREF="#NAN">NAN</A>)</TD></TR>
<TR><TD>2</TD><TD>Negative infinity (<A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>)</TD></TR>
<TR><TD>3</TD><TD>Negative real number</TD></TR>
<TR><TD>5</TD><TD>Negative zero (<A HREF="#NEGATIVE_ZERO">NEGATIVE_ZERO</A>)</TD></TR>
<TR><TD>6</TD><TD>Unsigned zero (<A HREF="#ZERO">ZERO</A>)</TD></TR>
<TR><TD>7</TD><TD>Positive zero (<A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>)</TD></TR>
<TR><TD>9</TD><TD>Positive real number</TD></TR>
<TR><TD>10</TD><TD>Positive infinity (<A HREF="#POSITIVE_INF">POSITIVE_INF</A>)</TD></TR>
<TR><TD>11</TD><TD>Unsigned infinity (<A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>)</TD></TR>
</TABLE>
<BR>
<B>Note:</B> This table was wrong in the documentation of TIGCCLIB release 1.5: negative and
unsigned infinity was swapped due a to typing error.</P>

<HR>
<H3><A NAME="float_to_bcd"><U>float_to_bcd</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><A HREF="#bcd">bcd</A> float_to_bcd (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Converts float to BCD.</B></P>

<P>bcd_to_float converts BCD structure <I>x</I> into an ordinary floating point value.
In fact, this function returns the same value as the argument, but with different interpretation.
This function, in a way, performs typecasting from an ordinary <CODE>float</CODE> type to a
<A HREF="#bcd">bcd</A> type. Beware that returned value is not an lvalue (ordinary C functions
never return lvalues, by the way), so you cannot do something like</P>
<PRE>float a;
...
float_to_bcd(a).exponent = 0x4002;
</PRE>
<P>To perform such assignments, use <A HREF="#bcd_var">bcd_var</A> macro.</P>

<HR>
<H3><A NAME="floor"><U>floor</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> floor (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Rounds down the floating point number.</B></P>

<P>floor finds the largest integer not greater than floating point argument <I>x</I>,
and returns the integer found as a floating point value.</P>

<HR>
<H3><A NAME="M_FLT_NEG"><U>FLT_NEG</U></A></H3>
<P><B>A deprecated macro used to define floating point numbers.</B></P>

<P>FLT_NEG is another deprecated macro which works exactly as
<A HREF="#M_FLT">FLT</A>, except it construct negative values
instead of positive ones. More precise, <CODE>FLT_NEG(x,y)</CODE> will simply be
translated to <CODE>-x.y</CODE> and <CODE>FLT_NEG(x)</CODE> will be translated to
<CODE>-x.0</CODE>. Anyway, you don't need to use the <CODE>FLT_NEG</CODE> macro any
more.</P>

<HR>
<H3><A NAME="flt"><U>flt</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> flt (<B><A HREF="keywords.html#short">long</A></B> x);</TD></TR></TABLE></P>
<P><B>Converts integer to floating point.</B></P>

<P>flt converts the (long) integer argument <I>x</I> to the floating point representation
of the same value. This routine performs the same operation as casting a long integer
value to float type using the <CODE>'(float)'</CODE> typecast operator,
but it is kept here for backwards compatibility.
This function is automatically called when any floating point function is called with
a long integer argument, to force a promotion of an integer to a floating
point type. In other words, integer values will be automatically promoted to the floating
point type when necessary. So, you can do assignment like <I>b</I>&nbsp;=&nbsp;<I>a</I>;
when <I>a</I> is an integer variable (or expression) and <I>b</I> is a standard floating
point variable (<B>float</B> or <B>double</B>). Also, you can calculate
sin(<I>a</I>) where <I>a</I> is an integer. In both cases, flt will be called automatically
to perform the promotion. At the fundamental level, flt is exactly the same routine as
<A HREF="#bcdbcd">bcdbcd</A>.</P>

<HR>
<H3><A NAME="M_FLT"><U>FLT</U></A></H3>
<P><B>A deprecated macro used to define floating point numbers.</B></P>

<P>FLT is a now deprecated macro which is kept here only to retain compatibility
with programs which are written with older releases of TIGCC (before 0.9),
which didn't support standard floating point numbers. Now,
<CODE>FLT(x,y)</CODE> will simply be translated to <CODE>x.y</CODE> and
<CODE>FLT(x)</CODE> will be translated to <CODE>x.0</CODE>, e.g.
<CODE>FLT(342,15)</CODE> will be translated to <CODE>342.15</CODE>,
<CODE>FLT(0,0001)</CODE> will be translated to <CODE>0.0001</CODE>, and
<CODE>FLT(4)</CODE> will be translated to <CODE>4.0</CODE>. Anyway, you don't
need to use the <CODE>FLT</CODE> macro any more.</P>

<HR>
<H3><A NAME="fmod"><U>fmod</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> fmod (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Calculates x modulo y, i.e. the remainder of x/y.</B></P>

<P>fmod returns <I>x</I> modulo <I>y</I>, i.e. it returns the remainder f, where
<I>x</I>&nbsp;=&nbsp;a&nbsp;*&nbsp;<I>y</I>&nbsp;+&nbsp;f for some integer a
and 0&nbsp;&lt;=&nbsp;f&nbsp;&lt;&nbsp;<I>y</I>. Where <I>y</I>&nbsp;=&nbsp;0, fmod returns 0.</P>

<HR>
<H3><A NAME="fmul"><U>fmul</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> fmul (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Floating point multiplication.</B></P>

<P>fmul returns the product of floating point arguments <I>x</I> and <I>y</I>.
This routine performs the same operation as the C <CODE>'*'</CODE> operator applied to floating
point operands, but it is kept here for backwards compatibility.
At the fundamental level, fmul is exactly the same routine as
<A HREF="#bcdmul">bcdmul</A>.
<BR><BR>
<B>Note:</B> fmul returns infinite result
in a case of overflow. See <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>,
<A HREF="#POSITIVE_INF">POSITIVE_INF</A> and <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A> for
more details.</P>

<HR>
<H3><A NAME="fneg"><U>fneg</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> fneg (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point negation.</B></P>

<P>fneg returns negated value of floating point argument <I>x</I>.
This routine performs the same operation as the C <CODE>'-'</CODE> unary minus operator applied
to a floating point operand, but it is kept here for backwards compatibility.
At the fundamental level, fneg is exactly the same routine as
<A HREF="#bcdneg">bcdneg</A>.</P>

<HR>
<H3><A NAME="fpisanint"><U>fpisanint</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> fpisanint (<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> <B><A HREF="keywords.html#short">long</A></B> *mantissa, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> exponent);</TD></TR></TABLE></P>
<P><B>Checks whether the floating point number is reducable to an integer.</B></P>

<P>fpisanint is an internal TIOS subroutine used in <A HREF="#pow">pow</A>.
It checks whether the floating point with the exponent <I>exponent</I>
and the mantissa pointed to by <I>mantissa</I> is reducable to an integer.
Returns <A HREF="alloc.html#Bool">TRUE</A> or <A HREF="alloc.html#Bool">FALSE</A>, depending
on the test.
<BR><BR>
<B>Note:</B> <B>long long</B> is not a typing error: it is a
<A HREF="gnuexts.html">GNU C extension</A> for representing very long integers (8-byte integers in this implementation).</P>

<HR>
<H3><A NAME="fpisodd"><U>fpisodd</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> fpisodd (<B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> <B><A HREF="keywords.html#short">long</A></B> *mantissa, <B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> exponent);</TD></TR></TABLE></P>
<P><B>Checks whether the integer part of a floating point number is an odd number.</B></P>

<P>fpisodd is an internal TIOS subroutine used in <A HREF="#pow">pow</A>.
It checks whether the integer part of the floating point with the
exponent <I>exponent</I> and the mantissa pointed to by <I>mantissa</I> is
an odd number. Returns <A HREF="alloc.html#Bool">TRUE</A> or <A HREF="alloc.html#Bool">FALSE</A>,
depending on the test. Also returns <A HREF="alloc.html#Bool">TRUE</A> if the integer
part is zero, although zero is not an odd number.
<BR><BR>
<B>Note:</B> <B>long long</B> is not a typing error: it is a
<A HREF="gnuexts.html">GNU C extension</A> for representing very long integers (8-byte integers in this implementation).</P>

<HR>
<H3><A NAME="frexp10"><U>frexp10</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> frexp10 (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#short">short</A></B> *exponent);</TD></TR></TABLE></P>
<P><B>Splits floating point number into mantissa and exponent.</B></P>

<P>frexp10 calculates the mantissa m (a floating point greater than or
equal to 0.1 and less than 1) and the integer value n, such that <I>x</I>
equals m*10^n. frexp stores n in the integer that <I>exponent</I>
points to, and returns the mantissa m.
<BR><BR>
<B>Note:</B> This routine is analogous to <CODE>frexp</CODE> in ANSI C math library, except
using base ten rather than base two.</P>

<HR>
<H3><A NAME="fsub"><U>fsub</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> fsub (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Floating point substraction.</B></P>

<P>fsub returns the difference of floating point arguments <I>x</I> and <I>y</I>.
This routine performs the same operation as the C <CODE>'-'</CODE> operator applied to floating
point operands, but it is kept here for backwards compatibility.
At the fundamental level, fsub is exactly the same routine as
<A HREF="#bcdsub">bcdsub</A>.</P>

<HR>
<H3><A NAME="hypot"><U>hypot</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> hypot (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Calculates hypotenuse of right triangle.</B></P>

<P>hypot returns the value z where z^2&nbsp;=&nbsp;<I>x</I>^2&nbsp;+&nbsp;<I>y</I>^2 and
z&nbsp;&gt;=&nbsp;0. This is equivalent to the length of the hypotenuse of a right
triangle, if the lengths of the two sides are <I>x</I> and <I>y</I>. Or, this
is also equivalent to the absolute value of the complex number
<I>x</I>&nbsp;+&nbsp;<I>y</I>&nbsp;<I>i</I>.
<BR><BR>
<B>Note:</B> hypot is implemented as macro which calls <A HREF="#fmul">fmul</A> (for squaring
<I>x</I> and <I>y</I>), <A HREF="#fadd">fadd</A> and <A HREF="#sqrt">sqrt</A>.</P>

<HR>
<H3><A NAME="init_float"><U>init_float</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> init_float (<B><A HREF="keywords.html#void">void</A></B>);</TD></TR></TABLE></P>
<P><B>Initializes the floating point emulator.</B></P>

<P>init_float initializes the TIOS floating point emulator. However, as far as I know,
you need not to call this function explicitely anywhere in your program, because TIOS
does it in the boot code. As this function is removed from AMS 2.xx, it is redefined
in this release of TIGCCLIB to do nothing (it is kept in this header file only for
compatibility with previous releases).
<BR><BR>
<B>Note:</B> TIOS fp emulator is, in fact, located in TIOS routine called <B>_bcd_math</B>.
This routine performs a set of arithmetic operations on binary coded decimal floating
point values. A two-byte emulator opcode word is needed after the call to <B>_bcd_math</B>
to instruct the emulator which operation will be performed, where are its operands, etc.
Operands may be in MC68000 registers, in the memory, or in "floating point registers"
(they are, in fact, memory locations on the stack frame from the aspect of the emulator).
If the "instruction" has immediate operand, there will be more than one extra inline word
after the call to <B>_bcd_math</B>.
Anyway, function <B>_bcd_math</B> is unusable in C programs (except
in <B>asm</B> statements), due to non-C calling convention. Fortunately, nearly
all operations supported by <B>_bcd_math</B> have also a built-in interface
in TIOS which is adapted to C calling convention.
That's why I completely bypassed <B>_bcd_math</B> function in this header
file. It may give additional flexibility for ASM programmers (sometimes the argument may be in
the register, sometimes in the memory, etc.). But in C, the arguments are always on the stack,
so this flexibility is not necessary.</P>

<HR>
<H3><A NAME="is_float_infinity"><U>is_float_infinity</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_float_infinity (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is an infinite number.</B></P>

<P>is_float_infinity is original TIOS name for the function which is aliased here as
<A HREF="#is_inf">is_inf</A>.</P>

<HR>
<H3><A NAME="is_float_negative_zero"><U>is_float_negative_zero</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_float_negative_zero (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is negative zero.</B></P>

<P>is_float_negative_zero is original TIOS name for the function which is aliased here as
<A HREF="#is_nzero">is_nzero</A>.</P>

<HR>
<H3><A NAME="is_float_positive_zero"><U>is_float_positive_zero</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_float_positive_zero (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is positive zero.</B></P>

<P>is_float_positive_zero is original TIOS name for the function which is aliased here as
<A HREF="#is_pzero">is_pzero</A>.</P>

<HR>
<H3><A NAME="is_float_signed_infinity"><U>is_float_signed_infinity</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_float_signed_infinity (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is signed infinity.</B></P>

<P>is_float_signed_infinity is original TIOS name for the function which is aliased here as
<A HREF="#is_sinf">is_sinf</A>.</P>

<HR>
<H3><A NAME="is_float_transfinite"><U>is_float_transfinite</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_float_transfinite (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is a transfinite number.</B></P>

<P>is_float_transfinite is original TIOS name for the function which is aliased here as
<A HREF="#is_transfinite">is_transfinite</A>.</P>

<HR>
<H3><A NAME="is_float_unsigned_inf_or_nan"><U>is_float_unsigned_inf_or_nan</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_float_unsigned_inf_or_nan (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is unsigned infinity or Not_a_Number.</B></P>

<P>is_float_unsigned_inf_or_nan is original TIOS name for the function which is aliased here as
<A HREF="#is_uinf_or_nan">is_uinf_or_nan</A>.</P>

<HR>
<H3><A NAME="is_float_unsigned_zero"><U>is_float_unsigned_zero</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_float_unsigned_zero (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is unsigned zero.</B></P>

<P>is_float_unsigned_zero is original TIOS name for the function which is aliased here as
<A HREF="#is_uzero">is_uzero</A>.</P>

<HR>
<H3><A NAME="is_inf"><U>is_inf</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_inf (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is an infinite number.</B></P>

<P>is_inf returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is an infinite number
(i.e. <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>, <A HREF="#POSITIVE_INF">POSITIVE_INF</A>
or <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>), else returns <A HREF="alloc.html#Bool">FALSE</A>.
Infinite values are produced when the result is unbounded (for example dividing by
zero), or in case of overflow. This function is an alias for TIOS function
originally called <A HREF="#is_float_infinity">is_float_infinity</A>.</P>

<HR>
<H3><A NAME="is_nan"><U>is_nan</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_nan (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is Not_a_Number.</B></P>

<P>is_nan returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is <A HREF="#NAN">NAN</A>
(Not_a_Number), else returns <A HREF="alloc.html#Bool">FALSE</A>. Not_a_Number is a special
value which is produced as a result of all operations when the result is undefined
or non-real, for example dividing zero with zero, calculating the logarithm of
a negative number, etc.</P>

<HR>
<H3><A NAME="is_nzero"><U>is_nzero</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_nzero (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is negative zero.</B></P>

<P>is_nzero returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is a negative zero
(i.e. infinitely small negative quantity, see <A HREF="#NEGATIVE_ZERO">NEGATIVE_ZERO</A>), else returns <A HREF="alloc.html#Bool">FALSE</A>.
This function is an alias for TIOS function
originally called <A HREF="#is_float_negative_zero">is_float_negative_zero</A>.</P>

<HR>
<H3><A NAME="is_pzero"><U>is_pzero</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_pzero (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is positive zero.</B></P>

<P>is_pzero returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is a positive zero
(i.e. infinitely small positive quantity, see <A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>), else returns <A HREF="alloc.html#Bool">FALSE</A>.
This function is an alias for TIOS function
originally called <A HREF="#is_float_positive_zero">is_float_positive_zero</A>.</P>

<HR>
<H3><A NAME="is_sinf"><U>is_sinf</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_sinf (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is signed infinity.</B></P>

<P>is_sinf returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is a signed infinity
(i.e. <A HREF="#POSITIVE_INF">POSITIVE_INF</A> or <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>),
else returns <A HREF="alloc.html#Bool">FALSE</A>.
This function is an alias for TIOS function
originally called <A HREF="#is_float_signed_infinity">is_float_signed_infinity</A>.</P>

<HR>
<H3><A NAME="is_transfinite"><U>is_transfinite</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_transfinite (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is a transfinite number.</B></P>

<P>is_transfinite returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is
a transfinite number, else returns <A HREF="alloc.html#Bool">FALSE</A>.
Transfinite numbers are all infinite numbers
(<A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>, <A HREF="#POSITIVE_INF">POSITIVE_INF</A>
and <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>) and <A HREF="#NAN">NAN</A>.
This function is an alias for TIOS function originally called
<A HREF="#is_float_transfinite">is_float_transfinite</A>.</P>

<HR>
<H3><A NAME="is_uinf_or_nan"><U>is_uinf_or_nan</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_uinf_or_nan (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is unsigned infinity or Not_a_Number.</B></P>

<P>is_uinf_or_nan returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is
<A HREF="#UNSIGNED_INF">UNSIGNED_INF</A> or <A HREF="#NAN">NAN</A>,
else returns <A HREF="alloc.html#Bool">FALSE</A>. These two special numbers
are treated very similarly in TIOS. This function is an alias for
TIOS function originally called
<A HREF="#is_float_unsigned_inf_or_nan">is_float_unsigned_inf_or_nan</A>.</P>

<HR>
<H3><A NAME="is_uzero"><U>is_uzero</U></A></H3>
<P><A HREF="httigcc.html#minams">AMS 1.01 or higher</A></P>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">short</A></B> is_uzero (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Checks whether the argument is unsigned zero.</B></P>

<P>is_uzero returns <A HREF="alloc.html#Bool">TRUE</A> if <I>x</I> is an unsigned zero
(i.e. infinitely small quantity with indeterminate sign, see <A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A>),
else returns <A HREF="alloc.html#Bool">FALSE</A>.
This function is an alias for TIOS function
originally called <A HREF="#is_float_unsigned_zero">is_float_unsigned_zero</A>.</P>

<HR>
<H3><A NAME="itrig"><U>itrig</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> itrig (<B><A HREF="keywords.html#short">short</A></B> option, <B><A HREF="keywords.html#short">short</A></B> deg_flag, <B><A HREF="keywords.html#float">float</A></B> *xptr, <B><A HREF="keywords.html#float">float</A></B> *result);</TD></TR></TABLE></P>
<P><B>Generic subroutine for calculating inverse trigonometric functions.</B></P>

<P>itrig is a TIOS subroutine which is used internally for calculating
inverse trigonometric functions, i.e. in TIOS functions
<A HREF="#asin">asin</A>, <A HREF="#acos">acos</A> and
<A HREF="#atan">atan</A>. It calculates the arc sine, the arc cosine or
the arc tangent of the floating point value pointed to by <I>xptr</I>, and stores the result in
the floating point destination pointed to by <I>result</I>.
The result will be in radians if <I>deg_flag</I> is 0, or in degrees if
<I>deg_flag</I> is 1 (it seems that these two values are only legal values
for <I>deg_flag</I>). Parameter <I>option</I> determines which inverse
trigonometric function will be calculated: the arc sine if <I>option</I>&nbsp;=&nbsp;1,
the arc cosine if <I>option</I>&nbsp;=&nbsp;2 and the arc tangent if
<I>option</I>&nbsp;=&nbsp;4. I don't know whether these values are the
only legal values for <I>option</I>, but I believe so.
<BR><BR>
<B>Note:</B> The parameter <I>xptr</I> is not a pointer to <B>const</B>
value. This means that the value pointed to by it may be changed. In normal
cases this would not appear, but this need not to be true if the structure pointed
to by <I>xptr</I> contains wrong values (for example, arguments out of the function
domain, unnormalized values, etc.).</P>

<HR>
<H3><A NAME="ldexp10"><U>ldexp10</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> ldexp10 (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#short">short</A></B> exponent);</TD></TR></TABLE></P>
<P><B>Calculates x times 10 raised to exponent.</B></P>

<P>ldexp10 calculates <I>x</I> times 10 raised to <I>exponent</I>, and returns the
result, i.e. returns <I>x</I>*10^<I>exponent</I>. Strictly speaking, ldexp10 is
a macro, not a function.
<BR><BR>
<B>Note:</B> This routine is analogous to <CODE>ldexp</CODE> in ANSI C math library, except
using base ten rather than base two.</P>

<HR>
<H3><A NAME="log"><U>log</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> log (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point natural logarithm (base <B>e</B>).</B></P>

<P>log returns the natural logarithm of floating point argument <I>x</I>.
<BR><BR>
<B>Note:</B> log will return <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A> if the argument is
zero, or <A HREF="#NAN">NAN</A> if the argument is negative.</P>

<HR>
<H3><A NAME="log10"><U>log10</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> log10 (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point logarithm, base 10.</B></P>

<P>log10 returns the base 10 logarithm of floating point argument <I>x</I>.
<BR><BR>
<B>Note:</B> log will return <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A> if the argument is
zero, or <A HREF="#NAN">NAN</A> if the argument is negative.</P>

<HR>
<H3><A NAME="modf"><U>modf</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> modf (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> *ipart);</TD></TR></TABLE></P>
<P><B>Splits floating point value into integer and fraction part.</B></P>

<P>modf breaks the floating point value <I>x</I> into two parts: the integer and the
fraction, both having the same sign as <I>x</I>. It stores the integer in a floating point
destination pointed to by
<I>ipart</I> and returns the fractional part of <I>x</I>.</P>

<HR>
<H3><A NAME="pow"><U>pow</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> pow (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#float">float</A></B> y);</TD></TR></TABLE></P>
<P><B>Floating point power function.</B></P>

<P>pow returns <I>x</I>^<I>y</I>, <I>x</I> to the <I>y</I> (i.e. <I>x</I> raised to the
<I>y</I>-th power).
<BR><BR>
<B>Note:</B> pow will return an infinite result (see <A HREF="#POSITIVE_INF">POSITIVE_INF</A>,
<A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>, <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>)
in a case of overflow. If both <I>x</I> and <I>y</I> are zeros, pow will return 1.
If <I>x</I> is negative, the correct result will be produced only if <I>y</I> can
be represented as a whole number, or as a fraction with odd denominator; otherwise,
pow will return a garbage (not <A HREF="#NAN">NAN</A>) which sometimes even not
satisfy the floating point BCD format (digits greater than 9 etc.), so be careful in
a case when <I>x</I> is negative!</P>

<HR>
<H3><A NAME="round12_err"><U>round12_err</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> round12_err (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#short">short</A></B> error_code);</TD></TR></TABLE></P>
<P><B>Rounds the floating point number to 12 significant digits, throwing an error if unsuccessful.</B></P>

<P>round12_err is identical as <A HREF="#round12">round12</A>, except it throws an
error with code <I>error_code</I> if the absolute value of the argument is greater or
equal than 10^1000, or if the argument is a transfinite number (see
<A HREF="#is_transfinite">is_transfinite</A>), and it rounds arguments whose absolute
values are smaller than 10^-1000 to <A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A>.</P>

<HR>
<H3><A NAME="round12"><U>round12</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> round12 (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Rounds the floating point number to 12 significant digits.</B></P>

<P>round12 returns the value of the floating point argument <I>x</I> rounded
to 12 significant digits. TIOS sometimes does such rounding, for example when
TIOS updates coordinate values (xc, yc, etc.), during printing approximate
results, or when TIOS stores a value to system variables like xmin, xmax etc.
(strictly speaking, TIOS calls <A HREF="#round12_err">round12_err</A> instead
of round12 in such cases).</P>

<HR>
<H3><A NAME="round14"><U>round14</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> round14 (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Rounds the floating point number to 14 significant digits.</B></P>

<P>round14 returns the value of the floating point argument <I>x</I> rounded
to 14 significant digits. Also, arguments whose absolute values are greater or equal than 10^8192
are rounded to <A HREF="#POSITIVE_INF">POSITIVE_INF</A> or
<A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>, and arguments whose absolute values are smaller
than 10^-8192 are rounded to <A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A> or
<A HREF="#NEGATIVE_ZERO">NEGATIVE_ZERO</A>. TIOS always does such rounding
before storing a floating point value to a variable.</P>

<HR>
<H3><A NAME="sin"><U>sin</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> sin (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point sine.</B></P>

<P>sin returns the sine of floating point argument <I>x</I>, which is assumed
to be specified in radians.
<BR><BR>
<B>Note:</B> sin will return <A HREF="#NAN">NAN</A> if the argument is so big that
reducing to the main period can't be performed without complete losing of
significant digits (i.e. when the magnitude of <I>x</I> is greater than 1e13).</P>

<HR>
<H3><A NAME="sincos"><U>sincos</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> sincos (<B><A HREF="keywords.html#float">float</A></B> x, <B><A HREF="keywords.html#short">short</A></B> deg_flag, <B><A HREF="keywords.html#float">float</A></B> *sine, <B><A HREF="keywords.html#float">float</A></B> *cosine);</TD></TR></TABLE></P>
<P><B>Calculates both sine and cosine in one turn.</B></P>

<P>sincos calculates both the sine and the cosine of floating point argument <I>x</I>,
and stores the results in floating point destinationss pointed to by <I>sine</I> and
<I>cosine</I>. The argument <I>x</I> is assumed to be specified in radians
if <I>deg_flag</I> is 0, or in degrees if <I>deg_flag</I> is 1 (it seems that
these two values are only legal values for <I>deg_flag</I>). See also notes
related to <A HREF="#sin">sin</A> and <A HREF="#cos">cos</A>.</P>

<P>See also: <A HREF="#sin">sin</A>, <A HREF="#cos">cos</A></P>
<HR>
<H3><A NAME="sinh"><U>sinh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> sinh (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point hyperbolic sine.</B></P>

<P>sinh returns the hyperbolic sine of floating point argument <I>x</I>.
Hyperbolic sine is defined as (exp(x)-exp(-x))/2.
<BR><BR>
<B>Note:</B> sinh will return <A HREF="#POSITIVE_INF">POSITIVE_INF</A> or
<A HREF="#NEGATIVE_INF">NEGATIVE_INF</A> in a case of overflow.</P>

<HR>
<H3><A NAME="sqrt"><U>sqrt</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> sqrt (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point square root.</B></P>

<P>sqrt returns the positive square root of floating point argument <I>x</I>.
<BR><BR>
<B>Note:</B> If the argument is negative, there will be no error, but the result
will be invalid.</P>

<HR>
<H3><A NAME="tan"><U>tan</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> tan (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point tangent.</B></P>

<P>tan returns the tangent of floating point argument <I>x</I>, which is assumed
to be specified in radians.
<BR><BR>
<B>Note:</B> tan will return <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A> for all arguments
for which the tangent is infinity. Also, it will return <A HREF="#NAN">NAN</A> if the
argument is so big that reducing to the main period can't be performed without
complete losing of significant digits (i.e. when the magnitude of <I>x</I> is
greater than 1e13).</P>

<HR>
<H3><A NAME="tanh"><U>tanh</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#float">float</A></B> tanh (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Floating point hyperbolic tangent.</B></P>

<P>sinh returns the hyperbolic cosine of floating point argument <I>x</I>.
Hyperbolic tangent is defined as sinh(x)/cosh(x).</P>

<HR>
<H3><A NAME="trig"><U>trig</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#void">void</A></B> trig (<B><A HREF="keywords.html#short">short</A></B> option, <B><A HREF="keywords.html#short">short</A></B> deg_flag, <B><A HREF="keywords.html#const">const</A></B> <B><A HREF="keywords.html#float">float</A></B> *xptr, <B><A HREF="keywords.html#float">float</A></B> *sine, <B><A HREF="keywords.html#float">float</A></B> *cosine, <B><A HREF="keywords.html#float">float</A></B> *tangent);</TD></TR></TABLE></P>
<P><B>Generic subroutine for calculating trigonometric functions.</B></P>

<P>trig is a TIOS subroutine which is used internally for calculating
trigonometric functions, i.e. in TIOS functions
<A HREF="#sin">sin</A>, <A HREF="#cos">cos</A>, <A HREF="#sincos">sincos</A> and
<A HREF="#tan">tan</A>. It calculates simultaneously the sine, the cosine and
the tangent of the floating point value pointed to by <I>xptr</I>, and stores the results in
floating point destinations pointed to by <I>sine</I>, <I>cosine</I> and
<I>tangent</I>. The argument pointed to by <I>xptr</I> is assumed to be specified in radians
if <I>deg_flag</I> is 0, or in degrees if <I>deg_flag</I> is 1 (it seems that
these two values are only legal values for <I>deg_flag</I>). Parameter <I>option</I>
is not very clear to me: TIOS uses <I>option</I>&nbsp;=&nbsp;1 in
<A HREF="#sin">sin</A> and <A HREF="#sincos">sincos</A>, <I>option</I>&nbsp;=&nbsp;2
in <A HREF="#cos">cos</A>, and <I>option</I>&nbsp;=&nbsp;4 in
<A HREF="#tan">tan</A>. I don't know what is the difference between
<I>option</I>&nbsp;=&nbsp;1 and <I>option</I>&nbsp;=&nbsp;2, because both the
sine and the cosine are calculated regardless of the value of <I>option</I>.
I only noticed that the tangent will not be calculated if <I>option</I> is not
equal to 4.
<BR><BR>
<B>Note:</B> I included the description of this routine here only due to completeness: it
is more preferable to call particular trigonometric function instead.</P>

<HR>
<H3><A NAME="trunc"><U>trunc</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#short">long</A></B> trunc (<B><A HREF="keywords.html#float">float</A></B> x);</TD></TR></TABLE></P>
<P><B>Converts floating point to integer.</B></P>

<P>trunc truncates floating point argument <I>x</I> to the long integer result. Returns
zero in a case of overflow.
This routine performs the same operation as casting a floating point value
to an int type using <CODE>'(int)'</CODE>, <CODE>'(unsigned int)'</CODE> and
<CODE>'(long)'</CODE> typecast operators, but it is kept here for backwards compatibility.
This function is automatically called when any function which needs an integer is called with
a floating point arguments, to force a truncation of a floating point value to
an integer. Also, you can do assignments like <I>b</I>&nbsp;=&nbsp;<I>a</I>;
when <I>a</I> is a floating point variable (or expression) and <I>b</I> is an
integer variable. In both cases, trunc will be called automatically
to perform the truncation.
At the fundamental level, trunc is exactly the same routine as
<A HREF="#bcdlong">bcdlong</A>.</P>

<HR>
<H3><A NAME="FIVE"><U>FIVE</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> FIVE (5.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>FIVE is a predefined floating point constant with value 5.0, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="FOUR"><U>FOUR</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> FOUR (4.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>FOUR is a predefined floating point constant with value 4.0, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="HALF_PI"><U>HALF_PI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> HALF_PI (1.570796326794897)</TD></TR></TABLE></P>
<P><B>A constant with value <A HREF="#PI">PI</A>/2.</B></P>

<P>HALF_PI is a predefined floating point constant which approximates <A HREF="#PI">PI</A>/2 up to
16 significant digits, i.e. <CODE>1.570796326794897</CODE>.
Of course, it is the same as <CODE>PI/2.0</CODE>.</P>

<HR>
<H3><A NAME="HALF"><U>HALF</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> HALF (0.5)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>HALF is a predefined floating point constant with value 0.5, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="MINUS_ONE"><U>MINUS_ONE</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> MINUS_ONE (-1.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>MINUS_ONE is a predefined floating point constant with value -1.0, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="NAN"><U>NAN</U></A></H3>
<P><B>A constant defining an undefined value.</B></P>

<P><CODE>NAN</CODE> is an acronyme of "Not a Number". TIOS generates <CODE>NAN</CODE> when nothing can be deduced
about the magnitude of the result (for example, when dividing zero by zero, or when
substracting two infinities of the same sign). Also, TIOS generates <CODE>NAN</CODE> when the
argument of a function is out of legal range, excluding values of the argument which
produces infinity results. For example, <A HREF="#log">log</A> will produce <CODE>NAN</CODE> when the
argument is negative, but when the argument is zero, the result is
<A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>.
<BR><BR>
<CODE>NAN</CODE> also belongs to the class of "transfinite" numbers (see <A HREF="#is_transfinite">is_transfinite</A>).
Use <A HREF="#is_nan">is_nan</A> to check whether a value is <CODE>NAN</CODE>. This is a common
method to check in run time whether the arguments of the called math functions was legal.</P>

<P>See also: <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A></P>
<HR>
<H3><A NAME="NEGATIVE_INF"><U>NEGATIVE_INF</U></A></H3>
<P><B>Represents an infinitely large negative quantity.</B></P>

<P><CODE>NEGATIVE_INF</CODE> represents an infinitely large negative quantity. TIOS generates
<CODE>NEGATIVE_INF</CODE>
when the result is infinite in magnitude, but when it is known to be negative (for example,
<A HREF="#log">log</A> returns <CODE>NEGATIVE_INF</CODE> when the argument is equal to zero).
Other properties of <CODE>NEGATIVE_INF</CODE> are analogous like properties of
<A HREF="#POSITIVE_INF">POSITIVE_INF</A>.</P>

<P>See also: <A HREF="#POSITIVE_INF">POSITIVE_INF</A>, <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>, <A HREF="#NEGATIVE_ZERO">NEGATIVE_ZERO</A>, <A HREF="#is_transfinite">is_transfinite</A></P>
<HR>
<H3><A NAME="NEGATIVE_ZERO"><U>NEGATIVE_ZERO</U></A></H3>
<P><B>Represents an infinitely small quantity which is known to be always non-positive.</B></P>

<P><CODE>NEGATIVE_ZERO</CODE> is similar to <A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>, but it
represents an infinitely small quantity which is known to be always non-positive.
The properties of <CODE>NEGATIVE_ZERO</CODE> are analog to the properties of
<A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>. To check whether a value is a negative
zero, use <A HREF="#is_nzero">is_nzero</A>.</P>

<HR>
<H3><A NAME="ONE"><U>ONE</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> ONE (1.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>ONE is a predefined floating point constant with value 1.0, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="PI"><U>PI</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> PI (3.141592653589793)</TD></TR></TABLE></P>
<P><B>An approximated value of pi.</B></P>

<P>PI is a predefined floating point constant which approximates <B>pi</B> up
to 16 significant digits, i.e. <CODE>3.141592653589793</CODE>.</P>

<HR>
<H3><A NAME="POSITIVE_INF"><U>POSITIVE_INF</U></A></H3>
<P><B>Represents an infinitely large positive quantity.</B></P>

<P><CODE>POSITIVE_INF</CODE> represents an infinitely large positive quantity. TIOS generates <CODE>POSITIVE_INF</CODE>
when the result is infinite in magnitude, but when it is known to be positive (for example,
<A HREF="#atanh">atanh</A> returns <CODE>POSITIVE_INF</CODE> when the argument is equal to 1).
TIOS also generates <CODE>POSITIVE_INF</CODE> as the result of positive
overflow (i.e. when the result is positive and too big to be represented in
<CODE>float</CODE> type), and as the result of rounding extremely big positive
numbers using <A HREF="#round14">round14</A> or <A HREF="#round12_err">round12_err</A>.
<BR><BR>
TIOS allows much greater flexibility when working with "signed"
infinities than with <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>. To check whether a value
is signed infinity, use <A HREF="#is_sinf">is_sinf</A>. <CODE>POSITIVE_INF</CODE> belongs to the
class of "transfinite" numbers (see <A HREF="#is_transfinite">is_transfinite</A>).</P>

<P>See also: <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>, <A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>, <A HREF="#POSITIVE_ZERO">POSITIVE_ZERO</A>, <A HREF="#is_transfinite">is_transfinite</A></P>
<HR>
<H3><A NAME="POSITIVE_ZERO"><U>POSITIVE_ZERO</U></A></H3>
<P><B>Represents an infinitely small quantity which is known to be always non-negative.</B></P>

<P>In opposite to <A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A>, <CODE>POSITIVE_ZERO</CODE> is an infinitely
small quantity which is known to be always non-negative. It can be imagined as "the
smallest positive real number", altough something like this does not exist in reality.
TIOS generates <CODE>POSITIVE_ZERO</CODE> in cases when the result is zero, but it is known that the
result cannot be negative for any argument. For example, squaring of <A HREF="#ZERO">ZERO</A>
using <A HREF="#pow">pow</A> function will return <CODE>POSITIVE_ZERO</CODE>, because the square is
always non-negative. The same is true for <A HREF="#acosh">acosh</A> when the argument
is equal to 1, etc.
<BR><BR>
TIOS also generates <CODE>POSITIVE_ZERO</CODE> as the result of positive underflow (i.e. when the
result is positive, but too small to be represented in a <CODE>float</CODE> type),
and as the result of rounding extremely small positive numbers using
<A HREF="#round14">round14</A> or <A HREF="#round12_err">round12_err</A>.
To check whether a value is a positive zero, use <A HREF="#is_pzero">is_pzero</A>.
<BR><BR>
Dividing any finite strictly positive number by <A HREF="#POSITIVE_INF">POSITIVE_INF</A>
will produce <CODE>POSITIVE_ZERO</CODE> as the result. Dividing any finite strictly positive number by
POSITIVE_ZERO gives <A HREF="#POSITIVE_INF">POSITIVE_INF</A>, and dividing any finite
strictly negative number by <CODE>POSITIVE_ZERO</CODE> gives <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>.
<BR><BR>
<B>Note:</B> Try in TI Basic <CODE>'1/0'</CODE> and <CODE>'1/0^2'</CODE> to see that
<CODE>'0'</CODE> and <CODE>'0^2'</CODE> are not strictly the same
for TIOS. Clever, isn't it?</P>

<HR>
<H3><A NAME="TEN"><U>TEN</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> TEN (10.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>TEN is a predefined floating point constant with value 10.0, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="THREE"><U>THREE</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> THREE (3.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>THREE is a predefined floating point constant with value 3.0, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="TWO"><U>TWO</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> TWO (2.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>TWO is a predefined floating point constant with value 2.0, defined to
keep backwards compatibility.</P>

<HR>
<H3><A NAME="UNSIGNED_INF"><U>UNSIGNED_INF</U></A></H3>
<P><B>Represents an infinite quantity.</B></P>

<P><CODE>UNSIGNED_INF</CODE> represents a quantity which is known to be infinite in magnitude, but
when nothing can be deduced about its sign. For example, dividing of non-zero number
with "standard" zero (i.e. with <A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A>) or calculating
tangent of <B>pi</B>/2 will produce such value. TIOS mathematical functions are much
more limited in working with unsigned than with signed infinities (like
<A HREF="#POSITIVE_INF">POSITIVE_INF</A>). For example, arc tangent of <CODE>POSITIVE_INF</CODE> is
well defined and equals to <B>pi</B>/2, but arc tangent of <CODE>UNSIGNED_INF</CODE> is not unique determined.
<BR><BR>
Although <CODE>UNSIGNED_INF</CODE> is a much more "concrete"
quantity than <A HREF="#NAN">NAN</A>, TIOS very often does not make any difference
between these two quantities. To check whether a value is an unsigned infinity or
<A HREF="#NAN">NAN</A>, use <A HREF="#is_uinf_or_nan">is_uinf_or_nan</A>. If it is,
then you can use <A HREF="#is_nan">is_nan</A> for checking whether a value is <A HREF="#NAN">NAN</A>,
and if it it not, it must be an unsigned infinity. <CODE>UNSIGNED_INF</CODE> belongs to the
class of "transfinite" numbers (see <A HREF="#is_transfinite">is_transfinite</A>).</P>

<P>See also: <A HREF="#POSITIVE_INF">POSITIVE_INF</A>, <A HREF="#NEGATIVE_INF">NEGATIVE_INF</A>, <A HREF="#NAN">NAN</A>, <A HREF="#is_transfinite">is_transfinite</A></P>
<HR>
<H3><A NAME="UNSIGNED_ZERO"><U>UNSIGNED_ZERO</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> UNSIGNED_ZERO (0.)</TD></TR></TABLE></P>
<P><B>Represents an infinitely small quantity with indeterminate sign.</B></P>

<P>TIOS makes a difference between three types of zeros. <CODE>UNSIGNED_ZERO</CODE> is "ordinary" zero,
i.e. infinitely small quantity with indeterminate sign. It is identical to
<A HREF="#ZERO">ZERO</A>. Dividing any finite non-zero number by <CODE>UNSIGNED_ZERO</CODE> will produce
<A HREF="#UNSIGNED_INF">UNSIGNED_INF</A>.
<BR><BR>
All kind of zeros are equal when comparing using comparison operators or <A HREF="#fcmp">fcmp</A>. To check
whether a value is an unsigned zero, use <A HREF="#is_uzero">is_uzero</A>.</P>

<HR>
<H3><A NAME="ZERO"><U>ZERO</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="cpp.html#SEC10">#define</A></B> ZERO (0.)</TD></TR></TABLE></P>
<P><B>A deprecated constant.</B></P>

<P>ZERO is a predefined floating point constant with value <CODE>0.0</CODE>.
<CODE>ZERO</CODE> is the same as <A HREF="#UNSIGNED_ZERO">UNSIGNED_ZERO</A>.</P>

<HR>
<H3><A NAME="bcd"><U>bcd</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#struct">struct</A></B> {
<TABLE><TR><TD WIDTH="12"></TD><TD CLASS="CODE">
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">short</A></B> exponent;<BR>
<B><A HREF="keywords.html#short">unsigned</A></B> <B><A HREF="keywords.html#short">long</A></B> <B><A HREF="keywords.html#short">long</A></B> mantissa;<BR>
</TD></TR></TABLE>
} bcd __attribute__((__may_alias__));</TD></TR></TABLE></P>
<P><B>Represents the internal organization of floating point numbers
in the format recognized by the TIOS.</B></P>

<P>The <CODE>bcd</CODE> type represents the internal organization of floating point numbers
in the format recognized by the TIOS (the so-called SMAP II BCD format).
Note that <B>long long</B> is not a typing error: it is a
<A HREF="gnuexts.html">GNU C extension</A> for representing very long integers (8-byte integers in this implementation).
<BR><BR>
Here will be given the exact internal organization of floating point numbers. Magnitude of every
real number (except zero) can be represented as <I>m</I>*10^<I>e</I>, where <I>e</I>
(so-called exponent) is an integer, and <I>m</I> (so-called mantissa) is a real number
which satisfies condition 1&nbsp;&lt;=&nbsp;<I>m</I>&nbsp;&lt;&nbsp;10
(this is somewhat different convention than used in <A HREF="#frexp10">frexp10</A> function
which is derived from ANSI standard). <I>e</I> is
stored in the <I>exponent</I> field, and <I>m</I> in <I>mantissa</I> field of the
<CODE>bcd</CODE> structure. Details of storing format are given below. You don't
need to know these details, but they are given here for anybody who needs to
know more about floats on TI.
<BR><BR>
Field  <I>exponent</I> of the <CODE>bcd</CODE> structure contains <I>e</I>+0x4000
if the number is positive, or <I>e</I>+0xC000 if the number is negative. So, the most
significant bit of <I>exponent</I> is the sign of the number, but the format is not
2-complement code (more precise, it is sign_and_magnitude_0x4000_biased code). The exponent
is NOT bcd-coded (unlike the mantissa). Legal range for the <I>e</I> is from -16383 to +16382
(values -16384 and +16383 are reserved for some special values), although many math functions
are not very happy with extremely small or extremely big exponents. Keep your exponents in
the range from -999 to +999.
<BR><BR>
The mantissa is stored in BCD code. As the mantissa satisfies the condition
1&nbsp;&lt;=&nbsp;<I>m</I>&nbsp;&lt;&nbsp;10, it can be represented as
<I>m1.m2m3m4...</I> where <I>m1</I>, <I>m2</I> etc. are digits (0-9).
TIOS first truncates the mantissa up to 16 digits, or adds trailing zeros on the
end of the mantissa up to 16 digits if it is shorter than 16 digits. Then,
it stores the integer number <I>m1m2m3...m16</I> in <I>mantissa</I> field
of the <CODE>bcd</CODE> structure using packed BCD code (each digit in
4 bits).
<BR><BR>
Everything will be more clear on a concrete example. Look the number <CODE>379.25</CODE>. It can
be written as <CODE>3.7925*10^2</CODE>. So, <I>e</I> is <CODE>2</CODE>, and <I>m</I> is <CODE>3.7925</CODE>. As the
number is positive, <I>exponent</I> will contain <CODE>0x4000+2&nbsp;=&nbsp;0x4002</CODE>.
As the mantissa has less than 16 digits, it must be padded to <CODE>3.792500000000000</CODE>.
So, <I>mantissa</I> will contain the integer <CODE>3792500000000000</CODE>, i.e. it will contain
<CODE>0x3792500000000000</CODE> (note the strong correspodence between hex numbers and bcd coded
numbers: they have the same digits). So, to assign the value <CODE>379.25</CODE> to the
variable <I>a</I> of type <CODE>bcd</CODE>, you can use
<CODE>a.exponent&nbsp;=&nbsp;0x4002</CODE> and
<CODE>a.mantissa&nbsp;=&nbsp;0x3792500000000000</CODE>. Standard ANSI types
<CODE>float</CODE>, <CODE>double</CODE> and <CODE>long double</CODE> (all of
them are the same in TIGCC) are internally organized exactly at the same way
in TIGCC, except that from the aspect of the compiler, they are scalars, and
<CODE>bcd</CODE> is a structure, so you cannot simply cast <CODE>float</CODE>
to <CODE>bcd</CODE> and vice versa. For this purpose, use functions
(more precise macros) <A HREF="#float_to_bcd">float_to_bcd</A>,
<A HREF="#bcd_to_float">bcd_to_float</A> and <A HREF="#bcd_var">bcd_var</A>.
<BR><BR>
Note that due to the condition 1&nbsp;&lt;=&nbsp;<I>m</I>&nbsp;&lt;&nbsp;10,
the mantissa <B>must</B> be normalized (which means that the
first digit of the mantissa must not be zero). The consequence is that <I>mantissa</I>
field must always be greater or equal to 0x1000000000000000. You can construct
(artifically) structures in which this condition is not satisfied. Some functions
will work well with such (unnormalized) numbers, but many of them will not work correctly.
So, avoid creating of such illegal values: any unnormalized number may be represented
in normalized format. Anyway, don't worry about it: all numbers written using
"normal" methods are always normalized: you can create unnormalized numbers
only intentionally by direct accessing to mantissa part of a <CODE>bcd</CODE>
structure.</P>

<HR>
<H3><A NAME="ti_float"><U>ti_float</U></A></H3>
<P><TABLE BORDER="1" CELLPADDING="2"><TR><TD CLASS="CODE"><B><A HREF="keywords.html#typedef">typedef</A></B> <B><A HREF="keywords.html#float">float</A></B> ti_float;</TD></TR></TABLE></P>
<P><B>An alias for the standard ANSI float type.</B></P>

<P>ti_float is an alias for the standard ANSI float type, introduced to keep
backwards compatibility with antediluvian releases of TIGCC, which didn't
support standard ANSI floats. See <A HREF="#bcd">bcd</A>
for more info about the internal organization of floating point values.</P>

<HR>
<H3><A HREF="index.html">Return to the main index</A></H3>
</BODY>
</HTML>
